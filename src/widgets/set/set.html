<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="set-styles.html">

<link rel="import" href="../selector/selector.html">
<link rel="import" href="../drop-target/drop-target.html">

<dom-module id="yb-set">

  <style include="set-styles"></style>

  <template>
    <div id="widgetHandle" class="widget-handle" on-mousedown="mousedown" on-mouseup="mouseup"></div>
    <div id="widgetBody" class="widget-body">
      <div class="header">
        <yb-selector id="fromSelector" node-id="{{from}}"></yb-selector>
        <span class="connector"></span>
        <yb-selector id="viaSelector"  node-id="{{via}}"> </yb-selector>
        <span class="connector"></span>
        <yb-selector id="toSelector"   node-id="{{to}}">  </yb-selector>
      </div>
      <yb-drop-target id="setContent" on-nodes-dropped="nodesDropped">
      </yb-drop-target>
    </div>
  </template>
  
  <script>
    (function() {
      'use strict';
      
      Polymer({
        is: 'yb-set',
        properties: {
          from: {
            type: String,
            notify: true,
            observer: 'refreshSet',
          },
          via: {
            type: String,
            notify: true,
            observer: 'refreshSet',
          },
          to: {
            type: String,
            notify: true,
            observer: 'refreshSet',
          },
          selected: {
            type: Boolean,
            value: false,
            observer: 'handleSelectedChanged',
          },
        },
        created: function() {
          this.nodeWidgets      = new Set();
          this.nodeWidgetsInSet = new Map();
          
          this.dropTargets = new Set();
        },
        listeners: {
          nodeWidgetCreated:   'nodeWidgetCreated',
          nodeWidgetDestroyed: 'nodeWidgetDestroyed',
          dropTargetAttached:  'dropTargetAttached',
          dropTargetDetached:  'dropTargetDetached',
        },
        ready: function() {
        
          var self = this;
          
          self.widgetHandle = self.$.widgetHandle;
          self.widgetBody   = self.$.widgetBody;
          
          require(['client', 'node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
            self.refreshSet();
            self.onLinks = self.onLinks.bind(self);
            client.web.onLinks(self.onLinks);
          });
        },
        detached: function() {
          this.client.web.removeLinksListener(this.onLinks);
        },
        onLinks: function(linksAdded, linksRemoved) {
          this.updateSet(linksAdded, linksRemoved);
        },
        nodeWidgetCreated: function(event) {
          this.nodeWidgets.add(event.detail);
        },
        nodeWidgetDestroyed: function(event) {
          this.nodeWidgets.delete(event.detail);
        },
        dropTargetAttached: function(event) {
          this.dropTargets.add(event.detail);
        },
        dropTargetDetached: function(event) {
          this.dropTargets.delete(event.detail);
        },
        mousedown: function(event) {
          if (event.target === this.widgetHandle && event.button === 0) {
            this.fire('selected',  event);
            this.fire('dragStart', event);
          }
        },
        mouseup: function(event) {
          if (event.button === 2) {
            this.fire('selected',    event);
            this.fire('contextMenu', event);
          }
        },
        handleSelectedChanged: function() {
          this.toggleClass('selected', this.selected);
        },
        isFilterValid: function() {
          return ((this.from ? 1:0) + (this.via ? 1:0) + (this.to ? 1:0)) === 2;
        },
        filterLinks: function(links) {
          
          var self = this;
        
          if (!self.isFilterValid()) {
            return [];
          }
          return links.filter(function(link) {
            return (!self.from || self.node_id.toHex(link.from) === self.from) &&
                   (!self.via  || self.node_id.toHex(link.via)  === self.via) &&
                   (!self.to   || self.node_id.toHex(link.to)   === self.to);
          }).map(function(link) {
            if (!self.from) return link.from;
            if (!self.via)  return link.via;
            if (!self.to)   return link.to;
          });
        },
        refreshSet: function() {
          var self = this;
          
          self.$.setContent.set('enabled', self.isFilterValid());
          
          require(['client', 'node_id'], function(client, node_id) {
            self.node_id = node_id;
            var nodeIdKeys = new Set(self.filterLinks(client.web.getLinks()).map(function(nodeId) {
              return self.node_id.toMapKey(nodeId);
            }));
            self.nodeWidgetsInSet.forEach(function(nodeWidget, nodeIdKey) {
              if (!nodeIdKeys.has(nodeIdKey)) {
                self.removeNodeWidget(self.node_id.fromMapKey(nodeIdKey));
              }
            });
            nodeIdKeys.forEach(function(nodeIdKey) {
              if (!self.nodeWidgetsInSet.has(nodeIdKey)) {
                self.addNodeWidget(self.node_id.fromMapKey(nodeIdKey));
              }
            });
          });
        },
        updateSet: function(linksAdded, linksRemoved) {
        
          var self = this;
          
          self.filterLinks(linksAdded).forEach(function(nodeId) {
            self.addNodeWidget(nodeId);
          });
          
          self.filterLinks(linksRemoved).forEach(function(nodeId) {
            self.removeNodeWidget(nodeId);
          });
        },
        addNodeWidget: function(nodeId) {
          var nodeWidget = document.createElement('yb-node');
          nodeWidget.nodeId = this.node_id.toHex(nodeId);
          Polymer.dom(this.$.setContent).appendChild(nodeWidget);
          this.nodeWidgets.add(nodeWidget);
          this.nodeWidgetsInSet.set(this.node_id.toMapKey(nodeId), nodeWidget);
        },
        removeNodeWidget: function(nodeId) {
          var nodeWidget = this.nodeWidgetsInSet.get(this.node_id.toMapKey(nodeId));
          this.nodeWidgets.delete(nodeWidget);
          this.nodeWidgetsInSet.delete(this.node_id.toMapKey(nodeId));
          Polymer.dom(this.$.setContent).removeChild(nodeWidget);
        },
        nodesDropped: function(event) {
          var self = this;
          if (((self.from ? 1:0) + (self.via ? 1:0) + (self.to ? 1:0)) !== 2) {
            return;
          }
          var nodeWidgets = event.detail;
          require(['client', 'node_id'], function(client, node_id) {
            var links = Array.from(nodeWidgets).map(function(nodeWidget) {
              if (!self.from) {
                return {
                  from: node_id.fromHex(nodeWidget.nodeId),
                  via:  node_id.fromHex(self.via),
                  to:   node_id.fromHex(self.to),
                }
              } else if (!self.via) {
                return {
                  from: node_id.fromHex(self.from),
                  via:  node_id.fromHex(nodeWidget.nodeId),
                  to:   node_id.fromHex(self.to),
                }
              } else if (!self.to) {
                return {
                  from: node_id.fromHex(self.from),
                  via:  node_id.fromHex(self.via),
                  to:   node_id.fromHex(nodeWidget.nodeId),
                }
              }
            });
            client.addLinks(links);
          });
        },
      });
    })();
  </script>

</dom-module>