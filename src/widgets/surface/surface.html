<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-icon-item.html">

<link rel="import" href="../node/node.html">
<link rel="import" href="../connector/connector.html">
<link rel="import" href="../set/set.html">

<link rel="import" href="surface-styles.html">

<dom-module id="yb-surface">

  <style include="surface-styles"></style>

  <template>
  
    <div id="viewRoot">
    
      <div id="background" on-mousedown="backgroundMousedown" on-wheel="backgroundWheel"></div>
    
      <div id="boxSelection" class="hidden"></div>
    
    </div>
    
    <iron-dropdown id="backgroundDropdown" horizontal-align="left" vertical-align="top">
      <div class="dropdown-content">
        <paper-menu>
          <paper-icon-item on-tap="menuItem_CreateNode">
            <iron-icon icon="icons:add" item-icon></iron-icon>
            Add Node
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_CreateSet">
            <iron-icon icon="icons:add" item-icon></iron-icon>
            Add Set
          </paper-icon-item>
        </paper-menu>
      </div>
    </iron-dropdown>
    
    <iron-dropdown id="selectionDropdown" horizontal-align="left" vertical-align="top">
      <div class="dropdown-content">
        <paper-menu>
          <paper-icon-item on-tap="menuItem_CopySelected">
            <iron-icon icon="icons:content-copy" item-icon></iron-icon>
            Copy
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_RevealLinks">
            <iron-icon icon="icons:visibility" item-icon></iron-icon>
            Reveal Links
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_HideLinks">
            <iron-icon icon="icons:visibility-off" item-icon></iron-icon>
            Hide Links
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_HideSelected">
            <iron-icon icon="icons:visibility-off" item-icon></iron-icon>
            Hide
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_DeleteSelected">
            <iron-icon icon="icons:delete" item-icon></iron-icon>
            Delete
          </paper-icon-item>
        </paper-menu>
      </div>
    </iron-dropdown>
      
  </template>
  
  <script>
    (function() {
      'use strict';
      
      Polymer({
        is: 'yb-surface',
        created: function() {
          var self = this;
          
          self.viewTranslate = {x: 0, y: 0};
          self.viewScale     = 1.0;
          self.viewOrigin    = {x: 0, y: 0};
          
          self.viewMargin = 10000;
          
          self.nodeWidgets         = new Set();
          self.nodeWidgetsTopLevel = new Set();
          
          self.nodesToWidgets = new Map();
          
          self.connectors = new Set();
          self.connectorsFrom = new Map();
          self.connectorsVia  = new Map();
          self.connectorsTo   = new Map();
          self.activeConnectors = new Set();
          self.linksToConnectors = new Map();
          self.nodeWidgetsToConnectors = new Map();
          
          self.draggingConnectors = [];
          
          self.selectedNodeWidgets = new Set();
          self.selectedConnectors  = new Set();
          self.selectedSetWidgets  = new Set();
          
          self.setWidgets = new Set();
          
          self.dragdropAreas = new Set();
          
          require(['client', 'node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
          });
        },
        ready: function() {
        
          var self = this;
          
          self.viewRoot = self.$.viewRoot;
          
          self.setView(self.viewTranslate, self.viewScale, self.viewOrigin);
        
          require(['client', 'node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
            
            self.onLinks = self.onLinks.bind(self);
            client.onLinks(self.onLinks);
        
            self.createNodeWidget({x: 100, y: 40},  '52f9cf0e223d559931856acc98400f21');
            self.createNodeWidget({x: 100, y: 100}, '1264ed87a8274e5188f9020954811805');
            self.createNodeWidget({x: 100, y: 160}, '5c4d67cf88fd9c5dbc841dee378b6b4b');
            self.createNodeWidget({x: 185, y: 160}, '7e1b27583610201f8b48941d3637b13f');
            
//             self.createSetWidget({x: 400, y: 50});
          });
        },
        detached: function() {
          this.client.removeLinksListener(this.onLinks);
        },
        listeners: {
          contextmenu: 'oncontextmenu',
          nodeWidgetAttached:   'nodeWidgetAttached',
          nodeWidgetDetached:   'nodeWidgetDetached',
          dragdropAreaAttached: 'dragdropAreaAttached',
          dragdropAreaDetached: 'dragdropAreaDetached',
        },
        captureMouse: function(event, options) {
        
          var self = this;
        
          var cusorBeforeMouseCapture = document.body.style.cursor;
          
          if ('cursor' in options) {
            document.body.style.cursor = options.cursor;
          }
          
          var startPosPage = {
            x: event.pageX,
            y: event.pageY,
          }
          
          var eventTargetRectView = self.getElementRectInView(event.target);
          
          var startPosView = {
            x: eventTargetRectView.left + event.offsetX,
            y: eventTargetRectView.top  + event.offsetY,
          }
          
          var lastPosPage = startPosPage;
          var lastPosView = startPosView;
          
          self.classList.add('mouse-captured');
          
          self.$.background.addEventListener('mousemove', mousemove);
          
          function mousemove(event) {
          
            event.stopImmediatePropagation();
          
            var currentPosPage = {
              x: event.pageX,
              y: event.pageY,
            }
          
            var currentPosView = {
              x: event.offsetX - self.viewMargin,
              y: event.offsetY - self.viewMargin,
            }
          
            var dragDeltaView = {
              x: (event.offsetX - self.viewMargin) - startPosView.x,
              y: (event.offsetY - self.viewMargin) - startPosView.y,
            }
            
            var dragDeltaPage = {
              x: event.pageX - startPosPage.x,
              y: event.pageY - startPosPage.y,
            }
            
            var currentDeltaPage = {
              x: currentPosPage.x - lastPosPage.x,
              y: currentPosPage.y - lastPosPage.y,
            }
            
            var currentDeltaView = {
              x: currentPosView.x - lastPosView.x,
              y: currentPosView.y - lastPosView.y,
            }
          
            if ('mousemove' in options) {
              options.mousemove({
                event: event,
                currentPosPage: currentPosPage,
                currentPosView: currentPosView,
                dragDeltaPage: dragDeltaPage,
                dragDeltaView: dragDeltaView,
                currentDeltaPage: currentDeltaPage,
                currentDeltaView: currentDeltaView,
              });
            }
            
            lastPosPage = currentPosPage;
            lastPosView = currentPosView;
          }
          
          function mouseup(event) {
          
            self.$.background.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup',   mouseup);
            
            document.body.style.cursor = cusorBeforeMouseCapture;
          
            self.classList.remove('mouse-captured');
            
            if ('mouseup' in options) {
              options.mouseup(event);
            }
          }
          
          window.addEventListener('mouseup',   mouseup);
        },
        startViewDrag: function(event) {
          var self = this;
          event.preventDefault();
          self.captureMouse(event, {
            cursor: '-webkit-grabbing',
            mousemove: function(options) {
              self.moveView(options.currentDeltaPage);
            }
          });
          return false;
        },
        setView: function(translate, scale, origin) {
          this.viewTranslate = translate;
          this.viewScale     = scale;
          this.viewOrigin    = origin;
          this.viewRoot.style.transform = 'translate(' + translate.x + 'px, ' + translate.y + 'px) scale(' + scale + ')';
          this.viewRoot.style['transform-origin'] = origin.x + 'px ' + origin.y + 'px';
        },
        moveView: function(offset) {
          this.setView({
              x: this.viewTranslate.x + offset.x,
              y: this.viewTranslate.y + offset.y,
            },
            this.viewScale,
            this.viewOrigin
          );
        },
        zoomView: function(scaleMultiplier) {
          this.setView(this.viewTranslate, this.viewScale * scaleMultiplier, this.viewOrigin);
        },
        zoomOnPosition: function(position, zoomOffset) {
          this.setView(
            {
              x: this.viewTranslate.x + ((position.x - this.viewOrigin.x) * (this.viewScale - 1.0)),
              y: this.viewTranslate.y + ((position.y - this.viewOrigin.y) * (this.viewScale - 1.0)),
            },
            this.viewScale * (1.0 + zoomOffset),
            {
              x: position.x,
              y: position.y,
            }
          );
        },
        oncontextmenu: function(event) {
          event.preventDefault();
          return false;
        },
        backgroundMousedown: function(event) {
        
          this.closeSelectionMenu();
          
          if (!event.ctrlKey) {
            this.deselect();
          }
          
          var cursorPosition = {
            x: event.offsetX - this.viewMargin,
            y: event.offsetY - this.viewMargin,
          }
        
          if (event.button === 0) {
          
            this.closeBackgroundMenu();

            return this.startBoxSelection(event);
            
          } else if (event.button === 1) {
          
            return this.startViewDrag(event);
            
          } else if (event.button === 2) {
          
            this.lastMenuPosition = cursorPosition;
          
            var surfaceRect = this.getBoundingClientRect();
          
            this.openBackgroundMenu({
              x: event.pageX - surfaceRect.left,
              y: event.pageY - surfaceRect.top,
            });
            return false;
          }
        },
        backgroundWheel: function(event) {
          
          var cursorPosView = {
            x: event.offsetX - this.viewMargin,
            y: event.offsetY - this.viewMargin,
          }
          
          var zoomSpeed = null;
          if (event.deltaMode === 0) { // Pixels
            zoomSpeed = 0.08;
          } else if (event.deltaMode === 1) { // Lines
            zoomSpeed = 0.16;
          } else if (event.deltaMode === 2) { // Pages
            zoomSpeed = 0.2;
          } else {
            zoomSpeed = 0.08;
          }
          
          var zoomOffset = (event.deltaY < 0) ? zoomSpeed : -zoomSpeed;
          
          this.zoomOnPosition(cursorPosView, zoomOffset);
        },
        startBoxSelection: function(event) {
        
          event.preventDefault();
        
          var self = this;
          
          var dragStartOffset = {
            x: event.offsetX + self.$.background.offsetLeft,
            y: event.offsetY + self.$.background.offsetTop,
          }
          
          self.$.boxSelection.style.left = dragStartOffset.x + 'px';
          self.$.boxSelection.style.top  = dragStartOffset.y + 'px';
          self.$.boxSelection.style.width  = '0';
          self.$.boxSelection.style.height = '0';
          
          self.$.boxSelection.classList.remove('hidden');
          
          var alreadySelectedNodeWidgets = new Set(self.selectedNodeWidgets);
          var alreadySelectedSetWidgets  = new Set(self.selectedSetWidgets);
          
          self.captureMouse(event, {
            cursor: 'crosshair',
            mousemove: function(options) {
            
              var currentSelectionRect = {
                left:   Math.min(dragStartOffset.x, dragStartOffset.x + options.dragDeltaView.x),
                top:    Math.min(dragStartOffset.y, dragStartOffset.y + options.dragDeltaView.y),
                right:  Math.max(dragStartOffset.x, dragStartOffset.x + options.dragDeltaView.x),
                bottom: Math.max(dragStartOffset.y, dragStartOffset.y + options.dragDeltaView.y),
              }
              
              self.$.boxSelection.style.left   = currentSelectionRect.left + 'px';
              self.$.boxSelection.style.top    = currentSelectionRect.top  + 'px';
              self.$.boxSelection.style.width  = (currentSelectionRect.right  - currentSelectionRect.left) + 'px';
              self.$.boxSelection.style.height = (currentSelectionRect.bottom - currentSelectionRect.top)  + 'px';
              
              var nodesToSelect = new Set(self.getNodeWidgetsInRect(currentSelectionRect));
              alreadySelectedNodeWidgets.forEach(function(nodeWidget) {
                nodesToSelect.add(nodeWidget);
              });
              self.selectNodeWidgets(nodesToSelect);
              
              var setWidgetsToSelect = new Set(self.getSetWidgetsInRect(currentSelectionRect));
              alreadySelectedSetWidgets.forEach(function(nodeWidget) {
                setWidgetsToSelect.add(nodeWidget);
              });
              self.selectSetWidgets(setWidgetsToSelect);
            },
            mouseup: function(event) {
              self.$.boxSelection.classList.add('hidden');
              self.revealLinksBetweenNodeWidgets(self.selectedNodeWidgets, false);
            }
          });
          
          return false;
        },
        getElementRectInView: function(element) {
          if (!element.offsetParent || (element.offsetParent === this.viewRoot)) {
            return {
              left:   element.offsetLeft,
              top:    element.offsetTop,
              right:  element.offsetLeft + element.offsetWidth,
              bottom: element.offsetTop  + element.offsetHeight,
              width:  element.offsetWidth,
              height: element.offsetHeight,
            }
          } else {
            var offsetParentRect = this.getElementRectInView(element.offsetParent);
            return {
              left:   offsetParentRect.left + element.offsetLeft,
              top:    offsetParentRect.top  + element.offsetTop,
              right:  offsetParentRect.left + element.offsetLeft + element.offsetWidth,
              bottom: offsetParentRect.top  + element.offsetTop  + element.offsetHeight,
              width:  element.offsetWidth,
              height: element.offsetHeight,
            }
          }
        },
        getNodePosition: function(nodeWidget) {
          var nodeRect = this.getElementRectInView(nodeWidget);
          return {
            x: nodeRect.left,
            y: nodeRect.top,
          }
        },
        getNodeWidgetCenter: function(nodeWidget) {
          var nodeRect = this.getElementRectInView(nodeWidget);
          return {
            x: nodeRect.left + (nodeRect.width  / 2),
            y: nodeRect.top  + (nodeRect.height / 2),
          }
        },
        getNodeWidgetsInRect: function(rect) {
          var self = this;
          return Array.from(self.nodeWidgets).filter(function(nodeWidget) {
            var nodeRect = self.getElementRectInView(nodeWidget);
            return !(nodeRect.left > rect.right  || nodeRect.right  < rect.left ||
                     nodeRect.top  > rect.bottom || nodeRect.bottom < rect.top);
          });
        },
        getSetWidgetsInRect: function(rect) {
          return Array.from(this.setWidgets).filter(function(setWidget) {
            var setClientRect = setWidget.widgetHandle.getBoundingClientRect();
            var setRect = {
              left:   setWidget.position.x,
              top:    setWidget.position.y,
              right:  setWidget.position.x + setClientRect.width,
              bottom: setWidget.position.y + setClientRect.height,
            }
            return !(setRect.left > rect.right  || setRect.right  < rect.left ||
                     setRect.top  > rect.bottom || setRect.bottom < rect.top);
          });
        },
        getWidgetsForNode: function(id) {
          var idMapKey = this.node_id.toMapKey(id);
          if (this.nodesToWidgets.has(idMapKey)) {
            return this.nodesToWidgets.get(idMapKey);
          } else {
            return new Set();
          }
        },
        getWidgetDragdropAreaParent: function(widget) {
          if (widget.parentNode) {
            if (widget.parentNode.tagName === 'yb-dragdrop-area'.toUpperCase()) {
              return widget.parentNode;
            } else {
              return this.getWidgetDragdropAreaParent(widget.parentNode);
            }
          } else {
            return null;
          }
        },
        getNodeWidgetTriplesForLink: function(link, nodeWidgets) {
          var self = this;
          
          var nodeWidgetsFrom = self.getWidgetsForNode(link.from);
          var nodeWidgetsVia  = self.getWidgetsForNode(link.via);
          var nodeWidgetsTo   = self.getWidgetsForNode(link.to);
          
          if (nodeWidgets) {
            nodeWidgetsFrom = Array.from(nodeWidgetsFrom).filter(function(nodeWidget) {
              return nodeWidgets.has(nodeWidget);
            });
            nodeWidgetsVia = Array.from(nodeWidgetsVia).filter(function(nodeWidget) {
              return nodeWidgets.has(nodeWidget);
            });
            nodeWidgetsTo = Array.from(nodeWidgetsTo).filter(function(nodeWidget) {
              return nodeWidgets.has(nodeWidget);
            });
          }
          
          var nodeWidgetTriples = [];
        
          nodeWidgetsFrom.forEach(function(fromWidget) {
            nodeWidgetsVia.forEach(function(viaWidget) {
              nodeWidgetsTo.forEach(function(toWidget) {
                
                nodeWidgetTriples.push({
                  from: fromWidget,
                  via:  viaWidget,
                  to:   toWidget
                });
              });
            });
          });
          
          return nodeWidgetTriples;
        },
        getNodeWidgetTripleDistance: function(nodeWidgetTriple) {
          function distance(a, b) {
            var dx = a.x - b.x;
            var dy = a.y - b.y;
            return Math.sqrt(dx*dx + dy*dy);
          }
          
          var fromPos = this.getNodeWidgetCenter(nodeWidgetTriple.from);
          var viaPos  = this.getNodeWidgetCenter(nodeWidgetTriple.via);
          var toPos   = this.getNodeWidgetCenter(nodeWidgetTriple.to);
          
          return distance(fromPos, viaPos) + distance(viaPos, toPos);
        },
        makeConnectorsForLink: function(link, newConnectorOptions, nodeWidgets) {
          var self = this;
          
          var returnValues = {
            connectors: [],
            newConnectors: [],
            existingConnectors: [],
          }
        
          var nodeWidgetTriples = self.getNodeWidgetTriplesForLink(link, nodeWidgets);
          if (!nodeWidgetTriples.length) {
            return returnValues;
          }
          
          nodeWidgetTriples.sort(function(a, b) {
            return self.getNodeWidgetTripleDistance(a) - self.getNodeWidgetTripleDistance(b);
          });
          
          var nodeWidgetsUsed = new Set();
          
          nodeWidgetTriples.forEach(function(nodeWidgetTriple) {
          
            var connector = self.getConnectorForNodeWidgetTriple(nodeWidgetTriple);
            
            if (connector) {
              returnValues.existingConnectors.push(connector);
            }
            
            if (!connector &&
                !nodeWidgetsUsed.has(nodeWidgetTriple.from) &&
                !nodeWidgetsUsed.has(nodeWidgetTriple.via)  &&
                !nodeWidgetsUsed.has(nodeWidgetTriple.to)) {
              
              connector = self.createConnector(nodeWidgetTriple, newConnectorOptions);
              returnValues.newConnectors.push(connector);
            }
            
            if (connector) {
              returnValues.connectors.push(connector);
            }
            
            nodeWidgetsUsed.add(nodeWidgetTriple.from);
            nodeWidgetsUsed.add(nodeWidgetTriple.via);
            nodeWidgetsUsed.add(nodeWidgetTriple.to);
          });
          
          return returnValues;
        },
        getConnectorsForLink: function(link) {
          var linkKey = this.node_id.linkToKey(link);
          if (this.linksToConnectors.has(linkKey)) {
            return new Set(Array.from(this.linksToConnectors.get(linkKey)));
          } else {
            return new Set();
          }
        },
        getConnectorsBetweenNodeWidgets: function(nodeWidgets) {
          return Array.from(this.connectors).filter(function(connector) {
            return nodeWidgets.has(connector.fromWidget) &&
                   nodeWidgets.has(connector.viaWidget) &&
                   nodeWidgets.has(connector.toWidget);
          });
        },
        getConnectorForNodeWidgetTriple: function(nodeWidgetsTriple) {
          var nodeWidgetsLinkKey = this.node_id.linkToKey({
            from: nodeWidgetsTriple.from.widgetId,
            via:  nodeWidgetsTriple.via.widgetId,
            to:   nodeWidgetsTriple.to.widgetId,
          });
          return this.nodeWidgetsToConnectors.get(nodeWidgetsLinkKey);
        },
        onLinks: function(linksAdded, linksRemoved) {
          var self = this;
          
          var addedConnectorAnimations = self.highlightLinks(linksAdded, {color: '#2FB51E'});
          addedConnectorAnimations.forEach(function(animation, connector) {
            if (!self.activeConnectors.has(connector)) {
              animation.then(
                function() {
                  self.removeConnector(connector);
                },
                function() { }
              );
            }
          });
          
          var removeConnectorAnimations = self.highlightLinks(linksRemoved, {color: '#E05749', fadeOut: true, reverse: true});
          removeConnectorAnimations.forEach(function(animation, connector) {
            animation.then(
              function() {
                self.removeConnector(connector);
              },
              function() { }
            );
          });
        },
        highlightLinks: function(links, options) {
          var self = this;
          var connectorAnimations = new Map();
          links.forEach(function(link) {
            var result = self.makeConnectorsForLink(link, {active: false});
            result.connectors.forEach(function(connector) {
              var animation = self.highlightConnector(connector, options);
              connectorAnimations.set(connector, animation);
            });
          });
          return connectorAnimations;
        },
        highlightConnector: function(connector, options) {
          var self = this;
          var animationDuration = 300;
          if (connector.highlightAnimation) {
            console.log('cancelling existing connector highlight animation');
            connector.highlightAnimation.cancel();
            connector.highlightAnimation = null;
          }
          var color   = ('color'   in options) ? options.color   : '#fff';
          var fadeOut = ('fadeOut' in options) ? options.fadeOut : !self.activeConnectors.has(connector);
          var reverse = ('reverse' in options) ? options.reverse : false;
          var delay   = ('delay'   in options) ? options.delay : 0;
          var pathLength = connector.path.getTotalLength();
          connector.highlightAnimation = connector.path.animate(
            [
              {stroke: color, opacity: 1.0,                 'stroke-dasharray':  pathLength, 'stroke-dashoffset': reverse ? 0               : pathLength},
              {stroke: color, opacity: fadeOut ? 0.5 : 1.0, 'stroke-dasharray':  pathLength, 'stroke-dashoffset': reverse ? 0               : 0         },
              {stroke: color, opacity: fadeOut ? 0.0 : 1.0, 'stroke-dasharray':  pathLength, 'stroke-dashoffset': reverse ? -pathLength     : 0         },
            ],
            {
              duration: animationDuration,
              fill: fadeOut ? 'both' : 'backwards',
              delay: delay,
            }
          );
          return connector.highlightAnimation.finished;
        },
        startDraggingSelected: function(event) {
          var self = this;
          
          var draggingNodeWidgets = new Set(self.selectedNodeWidgets);
          
          if (draggingNodeWidgets.size) {
            self.classList.add('dragging-nodes');
          }
          
          // Initialize widget drag start positions
          draggingNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.dragStartPosition = self.getNodePosition(nodeWidget);
            nodeWidget.classList.add('dragging');
          });
          self.selectedSetWidgets.forEach(function(setWidget) {
            setWidget.dragStartPosition = setWidget.position;
          });
          
          
          // Setup drag-drop
          
          var dragdropAreasToDraggingNodes = new Map();
          draggingNodeWidgets.forEach(function(nodeWidget) {
            if (!self.nodeWidgetsTopLevel.has(nodeWidget)) {
              var dragdropArea = self.getWidgetDragdropAreaParent(nodeWidget);
              if (dragdropArea) {
                if (dragdropAreasToDraggingNodes.has(dragdropArea)) {
                  dragdropAreasToDraggingNodes.get(dragdropArea).add(nodeWidget);
                } else {
                  dragdropAreasToDraggingNodes.set(dragdropArea, new Set([nodeWidget]));
                }
              }
            }
          });
          
          function handleDragdropAreaDraggedOut(event) {
            var draggingNodesForArea = dragdropAreasToDraggingNodes.get(event.detail.dragdropArea);
            event.detail.oldWidgets.forEach(function(nodeWidget) {
              draggingNodesForArea.delete(nodeWidget);
            });
            if (draggingNodesForArea.size === 0) {
              event.detail.dragdropArea.removeEventListener('widgetsDraggedOut', handleDragdropAreaDraggedOut);
              dragdropAreasToDraggingNodes.delete(event.detail.dragdropArea);
            }
            
            event.detail.detachedWidgets.forEach(function(nodeWidget) {
              self.attachNodeWidget(nodeWidget, nodeWidget.dragStartPosition);
            });
          }
          
          dragdropAreasToDraggingNodes.forEach(function(nodeWidgets, dragdropArea) {
            dragdropArea.fire('widgetDragStart', {
              widgets: nodeWidgets,
              mouseEvent: event.detail,
            });
            dragdropArea.addEventListener('widgetsDraggedOut', handleDragdropAreaDraggedOut);
          });
          
          function dragdropAreaMouseover(event) {
            var dragdropArea = event.currentTarget;
            dragdropArea.classList.add('drop-hover');
            
            if (dragdropArea.dropOnHover) {
            
              var topLevelDraggingWidgets = Array.from(draggingNodeWidgets).filter(function(nodeWidget) {
                return self.nodeWidgetsTopLevel.has(nodeWidget);
              });
              
              var detachedWidgets = Array.from(topLevelDraggingWidgets).map(function(nodeWidget) {
                return self.detachNodeWidget(nodeWidget);
              });
              
              dragdropArea.fire('widgetsDraggedIn', {
                dragdropArea: dragdropArea,
                widgets: detachedWidgets,
                mouseEvent: event,
              });
              
              if (!dragdropAreasToDraggingNodes.has(dragdropArea)) {
                dragdropAreasToDraggingNodes.set(dragdropArea, new Set(detachedWidgets));
                dragdropArea.addEventListener('widgetsDraggedOut', handleDragdropAreaDraggedOut);
              } else {
                detachedWidgets.forEach(function(nodeWidget) {
                  dragdropAreasToDraggingNodes.get(dragdropArea).add(nodeWidget);
                });
              }
            }
          }
          function dragdropAreaMouseout(event) {
            var dragdropArea = event.currentTarget;
            dragdropArea.classList.remove('drop-hover');
          }
          function dragdropAreaMouseup(event) {
            var dragdropArea = event.currentTarget;
            dragdropArea.classList.remove('drop-hover');
            dragdropArea.fire('nodes-dropped', draggingNodeWidgets);
            draggingNodeWidgets.forEach(function(nodeWidget) {
              nodeWidget.style.left = nodeWidget.dragStartPosition.x + 'px';
              nodeWidget.style.top  = nodeWidget.dragStartPosition.y + 'px';
              self.updateConnectorsForNodeWidget(nodeWidget);
            });
            this.updateStyles();
          }
          
          self.dragdropAreas.forEach(function(dragdropArea) {
            if (dragdropArea.enabled) {
              dragdropArea.addEventListener('mouseover', dragdropAreaMouseover);
              dragdropArea.addEventListener('mouseout',  dragdropAreaMouseout);
              dragdropArea.addEventListener('mouseup',   dragdropAreaMouseup);
              dragdropArea.classList.add('drop-ready');
            }
          });
          
          
          // Begin drag
          
          self.captureMouse(event.detail, {
            cursor: '-webkit-grabbing',
            mousemove: function(options) {
            
              // Move top-level node widgets
              draggingNodeWidgets.forEach(function(draggingNodeWidget) {
              
                if (self.nodeWidgetsTopLevel.has(draggingNodeWidget)) {
              
                  var newPos = {
                    x: draggingNodeWidget.dragStartPosition.x + options.dragDeltaView.x,
                    y: draggingNodeWidget.dragStartPosition.y + options.dragDeltaView.y,
                  }
                  
                  draggingNodeWidget.style.left = newPos.x + 'px';
                  draggingNodeWidget.style.top  = newPos.y + 'px';
                
                  self.updateConnectorsForNodeWidget(draggingNodeWidget);
                }
              });
              
              // Move set widgets
              self.selectedSetWidgets.forEach(function(selectedSetWidget) {
                
                var newPos = {
                  x: selectedSetWidget.dragStartPosition.x + options.dragDeltaView.x,
                  y: selectedSetWidget.dragStartPosition.y + options.dragDeltaView.y,
                }
                
                selectedSetWidget.style.left = newPos.x + 'px';
                selectedSetWidget.style.top  = newPos.y + 'px';
                selectedSetWidget.position = newPos;
              });
              
              // Move node widgets in drag-drop areas
              dragdropAreasToDraggingNodes.forEach(function(nodeWidgets, dragdropArea) {
                dragdropArea.fire('widgetDrag', {
                  widgets: nodeWidgets,
                  options: options,
                });
              });
              
              return false;
            },
            mouseup: function() {
            
              self.classList.remove('dragging-nodes');
          
              draggingNodeWidgets.forEach(function(nodeWidget) {
                nodeWidget.classList.remove('dragging');
              });
              
              self.dragdropAreas.forEach(function(dragdropArea) {
                dragdropArea.removeEventListener('mouseover', dragdropAreaMouseover);
                dragdropArea.removeEventListener('mouseout',  dragdropAreaMouseout);
                dragdropArea.removeEventListener('mouseup',   dragdropAreaMouseup);
                dragdropArea.classList.remove('drop-ready');
              });
              
              dragdropAreasToDraggingNodes.forEach(function(nodeWidgets, dragdropArea) {
                dragdropArea.fire('widgetDragFinish', nodeWidgets);
                dragdropArea.removeEventListener('widgetsDraggedOut', handleDragdropAreaDraggedOut);
              });
            }
          });
        },
        createNodeWidget: function(position, id) {
        
          var self = this;
        
          var nodeWidget = document.createElement('yb-node');
          if (!id) {
            id = self.node_id.makeHex();
          }
          nodeWidget.nodeId = id;
          nodeWidget.style.position = 'absolute';
          nodeWidget.style.left = position.x + 'px';
          nodeWidget.style.top  = position.y + 'px';
          
          nodeWidget.addEventListener('dimensionsChanged', function(event) {
            self.updateConnectorsForNodeWidget(nodeWidget);
          });
          
          self.nodeWidgetsTopLevel.add(nodeWidget);
          
          var idMapKey = self.node_id.toMapKey(self.node_id.fromHex(id));
          
          if (!self.nodesToWidgets.has(idMapKey)) {
            self.nodesToWidgets.set(idMapKey, new Set([nodeWidget]));
          } else {
            self.nodesToWidgets.get(idMapKey).add(nodeWidget);
          }
          
          Polymer.dom(self.viewRoot).appendChild(nodeWidget);
          
          return nodeWidget;
        },
        attachNodeWidget: function(nodeWidget, position) {
          var self = this;
        
          nodeWidget.style.position = 'absolute';
          nodeWidget.style.left = position.x + 'px';
          nodeWidget.style.top  = position.y + 'px';
          
          nodeWidget.addEventListener('dimensionsChanged', function(event) {
            self.updateConnectorsForNodeWidget(nodeWidget);
          });
          
          if (!self.nodeWidgetsTopLevel.has(nodeWidget)) {
            self.nodeWidgetsTopLevel.add(nodeWidget);
            self._setupNodeWidgetConnectorDragging(nodeWidget);
            self._setupNodeWidgetMenu(nodeWidget);
          }
          
          var idMapKey = self.node_id.toMapKey(self.node_id.fromHex(nodeWidget.nodeId));
          
          if (!self.nodesToWidgets.has(idMapKey)) {
            self.nodesToWidgets.set(idMapKey, new Set([nodeWidget]));
          } else {
            self.nodesToWidgets.get(idMapKey).add(nodeWidget);
          }
          
          Polymer.dom(self.viewRoot).appendChild(nodeWidget);
        },
        detachNodeWidget: function(nodeWidget) {
          nodeWidget.classList.remove('yb-surface');
          this.nodeWidgetDetached({detail: nodeWidget});
          return Polymer.dom(this.viewRoot).removeChild(nodeWidget);
        },
        nodeWidgetAttached: function(event) {
          console.log('nodeWidgetAttached');
          var nodeWidget = event.detail;
          if (!this.nodeWidgets.has(nodeWidget)) {
            this.nodeWidgets.add(nodeWidget);
            this._setupNodeWidgetHighlighting(nodeWidget);
            this._setupNodeWidgetSelection(nodeWidget);
            this._setupNodeWidgetDragging(nodeWidget);
            this._setupNodeWidgetConnectorDragging(nodeWidget);
            this._setupNodeWidgetMenu(nodeWidget);
          }
        },
        nodeWidgetDetached: function(event) {
          var self = this;
        
          console.log('nodeWidgetDetached');
          var nodeWidget = event.detail;
          
          self.nodeWidgets.delete(nodeWidget);
          
          if (self.nodeWidgetsTopLevel.has(nodeWidget)) {
          
            var connectors = Array.from(nodeWidget.connectors());
            connectors.forEach(function(connector) {
              self.removeConnector(connector);
            });
          
            self.nodeWidgetsTopLevel.delete(nodeWidget);
          }
        },
        _setupNodeWidgetHighlighting: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('mouseover', function(event) {
            var nodeCopies = [];
            self.nodeWidgets.forEach(function(otherNodeWidget) {
              if (otherNodeWidget !== nodeWidget && otherNodeWidget.nodeId === nodeWidget.nodeId) {
                nodeCopies.push(otherNodeWidget);
                otherNodeWidget.set('highlighted', true);
              }
            });
            function stopHighlighting() {
              nodeWidget.removeEventListener('mouseout', stopHighlighting);
              nodeWidget.removeEventListener('detached', stopHighlighting);
              nodeCopies.forEach(function(nodeWidgetCopy) {
                nodeWidgetCopy.set('highlighted', false);
              });
            }
            nodeWidget.addEventListener('mouseout', stopHighlighting);
            nodeWidget.addEventListener('detached', stopHighlighting);
          });
        },
        _setupNodeWidgetSelection: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('selected', function(event) {
            if (!self.selectedNodeWidgets.has(nodeWidget)) {
              self.selectNodeWidgets([nodeWidget], event.detail.ctrlKey);
            }
          });
        },
        bringNodeWidgetToFront: function(nodeWidget) {
          if (this.nodeWidgetsTopLevel.has(nodeWidget)) {
            Polymer.dom(this.viewRoot).appendChild(nodeWidget);
          }
        },
        bringConnectorToFront: function(connector) {
          Polymer.dom(this.viewRoot).appendChild(connector);
        },
        bringSetWidgetToFront: function(setWidget) {
          Polymer.dom(this.viewRoot).appendChild(setWidget);
        },
        selectNodeWidgets: function(nodeWidgets, appendSelection) {
          var self = this;
          
          nodeWidgets = new Set(nodeWidgets);
        
          if (!appendSelection) {
            self.selectedNodeWidgets.forEach(function(nodeWidget) {
              if (!nodeWidgets.has(nodeWidget)) {
                nodeWidget.set('selected', false);
              }
            });
          }
          
          nodeWidgets.forEach(function(nodeWidget) {
            if (!self.selectedNodeWidgets.has(nodeWidget)) {
              nodeWidget.set('selected', true);
              if (appendSelection) {
                self.selectedNodeWidgets.add(nodeWidget);
              }
            }
          });
          
          if (!appendSelection) {
          
            self.selectedNodeWidgets = new Set(nodeWidgets);
            
            self.selectedConnectors.forEach(function(connector) {
              connector.set('selected', false);
            });
            self.selectedConnectors.clear();
            
            self.selectedSetWidgets.forEach(function(setWidget) {
              setWidget.set('selected', false);
            });
            self.selectedSetWidgets.clear();
          }
        },
        selectSetWidgets: function(setWidgets) {
          this.selectedSetWidgets.forEach(function(setWidget) {
            if (!setWidgets.has(setWidget)) {
              setWidget.set('selected', false);
            }
          });
          
          setWidgets.forEach(function(setWidget) {
            setWidget.set('selected', true);
          });
          
          this.selectedSetWidgets = new Set(setWidgets);
        },
        deselect: function() {
          this.selectedNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.set('selected', false);
          });
          this.selectedNodeWidgets.clear();
          
          this.selectedConnectors.forEach(function(connector) {
            connector.set('selected', false);
          });
          this.selectedConnectors.clear();
          
          this.selectedSetWidgets.forEach(function(setWidget) {
            setWidget.set('selected', false);
          });
          this.selectedSetWidgets.clear();
        },
        removeSelectedWidgets: function() {
          var self = this;
          
          var connectorsToDelete = new Set(self.selectedConnectors);
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.connectors().forEach(function(connector) {
              connectorsToDelete.add(connector);
            });
          });
          
          // Delete node widgets
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            self.nodeWidgetDetached(nodeWidget);
            Polymer.dom(self.viewRoot).removeChild(nodeWidget);
          });
          self.nodeWidgets = new Set(Array.from(self.nodeWidgets).filter(function(nodeWidget) {
            return !self.selectedNodeWidgets.has(nodeWidget);
          }));
          self.nodeWidgetsTopLevel = new Set(Array.from(self.nodeWidgetsTopLevel).filter(function(nodeWidget) {
            return !self.selectedNodeWidgets.has(nodeWidget);
          }));
          self.selectedNodeWidgets.clear();
          
          connectorsToDelete.forEach(function(connector) {
            connector.set('selected', false);
            self.hideConnector(connector);
          });
          
          // Find affected links
          var affectedLinks = new Set();
          self.selectedConnectors.forEach(function(connector) {
            affectedLinks.add(self.node_id.linkToKey({
              from: self.node_id.fromHex(connector.fromWidget.nodeId),
              via:  self.node_id.fromHex(connector.viaWidget.nodeId),
              to:   self.node_id.fromHex(connector.toWidget.nodeId)
            }));
          });
          
          self.selectedConnectors.clear();
          
          // Delete set widgets
          var setWidgetsToDelete = new Set(self.selectedSetWidgets);
          setWidgetsToDelete.forEach(function(setWidget) {
            self.removeSetWidget(setWidget);
          });
          
          return new Set(Array.from(affectedLinks).map(function(linkKey) {
            return self.node_id.linkFromKey(linkKey);
          }));
        },
        removeConnector: function(connector) {
          
          Polymer.dom(this.viewRoot).removeChild(connector);
          
          this.connectors.delete(connector);
          
          var linkKey = this.node_id.linkToKey({
            from: this.node_id.fromHex(connector.fromWidget.nodeId),
            via:  this.node_id.fromHex(connector.viaWidget.nodeId),
            to:   this.node_id.fromHex(connector.toWidget.nodeId),
          });
          var connectors = this.linksToConnectors.get(linkKey);
          if (connectors.size === 0) {
            this.linksToConnectors.delete(linkKey);
          }
          
          var nodeWidgetsKey = this.node_id.linkToKey({
            from: connector.fromWidget.widgetId,
            via:  connector.viaWidget.widgetId,
            to:   connector.toWidget.widgetId,
          });
          this.nodeWidgetsToConnectors.delete(nodeWidgetsKey);
          
          connector.fromWidget.connectorsFrom.delete(connector);
          connector.viaWidget.connectorsVia.delete(connector);
          connector.toWidget.connectorsTo.delete(connector);
          
          if (connector.highlightAnimation) {
            connector.highlightAnimation.cancel();
            connector.highlightAnimation = null;
          }
        },
        hideConnector: function(connector) {
          var self = this;
          self.activateConnector(connector, false);
          self.highlightConnector(connector, {color: '#E05749', fadeOut: true, reverse: true}).then(
            function() {
              self.removeConnector(connector);
            },
            function() { }
          );
        },
        copySelected: function(offset) {
          var self = this;
          
          var newNodeWidgets = new Set();
          var newConnectors  = new Set();
          var newSetWidgets  = new Set();
          
          var oldToNewNodeWidgetMap = new Map();
          
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
          
            var nodePos = self.getNodePosition(nodeWidget);
            
            var newPosition = {
              x: nodePos.x + (offset || 0),
              y: nodePos.y + (offset || 0),
            }
            
            var newNodeWidget = self.createNodeWidget(newPosition, nodeWidget.nodeId);
            newNodeWidgets.add(newNodeWidget);
            
            nodeWidget.set('selected', false);
            newNodeWidget.set('selected', true);
            
            oldToNewNodeWidgetMap.set(nodeWidget, newNodeWidget);
          });
          
          self.selectedConnectors.forEach(function(connector) {
            
            if (self.selectedNodeWidgets.has(connector.fromWidget) &&
                self.selectedNodeWidgets.has(connector.viaWidget) &&
                self.selectedNodeWidgets.has(connector.toWidget)) {
              
              var newConnector = self.createConnector({
                from: oldToNewNodeWidgetMap.get(connector.fromWidget),
                via:  oldToNewNodeWidgetMap.get(connector.viaWidget),
                to:   oldToNewNodeWidgetMap.get(connector.toWidget)
              });
              newConnectors.add(newConnector);
              
              connector.set('selected', false);
              newConnector.set('selected', true);
            }
          });
          
          self.selectedSetWidgets.forEach(function(setWidget) {
          
            var newPosition = {
              x: setWidget.position.x + (offset || 0),
              y: setWidget.position.y + (offset || 0),
            }
          
            var newSetWidget = self.createSetWidget(newPosition);
            newSetWidget.set('from', setWidget.from);
            newSetWidget.set('via',  setWidget.via);
            newSetWidget.set('to',   setWidget.to);
            
            newSetWidgets.add(newSetWidget);
            
            setWidget.set('selected', false);
            newSetWidget.set('selected', true);
          });
          
          self.selectedNodeWidgets = newNodeWidgets;
          self.selectedConnectors  = newConnectors;
          self.selectedSetWidgets  = newSetWidgets;
        },
        revealNodeWidgetTriples: function(nodeWidgets) {
          var self = this;
          
          var nodeIdsToWidgets = new Map();
          nodeWidgets.forEach(function(nodeWidget) {
            var nodeIdKey = self.node_id.toMapKey(self.node_id.fromHex(nodeWidget.nodeId));
            if (nodeIdsToWidgets.has(nodeIdKey)) {
              nodeIdsToWidgets.get(nodeIdKey).add(nodeWidget);
            } else {
              nodeIdsToWidgets.set(nodeIdKey, new Set([nodeWidget]));
            }
          });
          
          var nodeWidgetTriples = [];
          
          self.client.web.getLinks().forEach(function(link) {
            if (nodeIdsToWidgets.has(self.node_id.toMapKey(link.from)) &&
                nodeIdsToWidgets.has(self.node_id.toMapKey(link.via)) &&
                nodeIdsToWidgets.has(self.node_id.toMapKey(link.to))) {
              
              var nodeWidgetsFrom = nodeIdsToWidgets.get(self.node_id.toMapKey(link.from));
              var nodeWidgetsVia  = nodeIdsToWidgets.get(self.node_id.toMapKey(link.via));
              var nodeWidgetsTo   = nodeIdsToWidgets.get(self.node_id.toMapKey(link.to));
              
              nodeWidgetsFrom.forEach(function(nodeWidgetFrom) {
                nodeWidgetsVia.forEach(function(nodeWidgetVia) {
                  nodeWidgetsTo.forEach(function(nodeWidgetTo) {
                    
                    nodeWidgetTriples.push({
                      from: nodeWidgetFrom,
                      via:  nodeWidgetVia,
                      to:   nodeWidgetTo,
                    });
                  });
                });
              });
              
            }
          });
          
          return nodeWidgetTriples;
        },
        revealLinksBetweenNodeWidgets: function(nodeWidgets, activate) {
        
          var self = this;
          
          var delay = 0.0;
          
          self.client.web.getLinks().forEach(function(link) {
            var result = self.makeConnectorsForLink(link, {active: activate}, nodeWidgets);
            
            if (result.connectors.length) {
            
              result.newConnectors.forEach(function(connector) {
                var animation = self.highlightConnector(connector, {color: '#2FB51E', fadeOut: !activate, delay: delay});
                if (!activate) {
                  animation.then(
                    function() {
                      self.removeConnector(connector);
                    },
                    function() { }
                  );
                }
              });
              
              result.existingConnectors.forEach(function(connector) {
                if (!connector.active) {
                  self.activateConnector(connector);
                  var animation = self.highlightConnector(connector, {color: '#2FB51E', fadeOut: !activate, delay: delay});
                  if (!activate) {
                    animation.then(
                      function() {
                        self.removeConnector(connector);
                      },
                      function() { }
                    );
                  }
                }
              });
              
              delay += 150;
            }
          });
        },
        _setupNodeWidgetDragging: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('dragStart', function(event) {
            event.preventDefault();
            if (event.detail.shiftKey) {
              self.copySelected();
            }
            self.startDraggingSelected(event);
            return false;
          });
        },
        startNewConnectorDragFromSelected: function(event, dragStartPos) {
          var self = this;
          
          self.draggingConnectorNodes = {
            from: new Set(self.selectedNodeWidgets),
            via:  null,
            to:   null,
          }
          
          self.draggingConnectors = [];
          self.draggingConnectorNodes.from.forEach(function(fromNodeWidget) {
            var draggingConnector = document.createElement('yb-connector');
            draggingConnector.classList.add('inactive');
            draggingConnector.classList.add('dragging');
            var nodeCenter = self.getNodeWidgetCenter(fromNodeWidget);
            draggingConnector.set('fromPos', {
              x: nodeCenter.x + self.viewMargin,
              y: nodeCenter.y + self.viewMargin,
            });
            Polymer.dom(self.viewRoot).appendChild(draggingConnector);
            self.draggingConnectors.push(draggingConnector);
          });
          
          function handleOtherNodeMouseover(event) {
            var otherNodeWidget = event.currentTarget;
            var otherNodeCenter = self.getNodeWidgetCenter(otherNodeWidget);
            if (!self.draggingConnectorNodes.via) {
              if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
                self.draggingConnectorNodes.via = otherNodeWidget;
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('viaPos', {
                    x: otherNodeCenter.x + self.viewMargin,
                    y: otherNodeCenter.y + self.viewMargin,
                  });
                });
              }
            } else if (!self.draggingConnectorNodes.to) {
              if (otherNodeWidget !== self.draggingConnectorNodes.via) {
                self.draggingConnectorNodes.to = otherNodeWidget;
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('toPos', {
                    x: otherNodeCenter.x + self.viewMargin,
                    y: otherNodeCenter.y + self.viewMargin,
                  });
                });
              }
            }
          }
          
          self.nodeWidgetsTopLevel.forEach(function(otherNodeWidget) {
            if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
              otherNodeWidget.addEventListener('mouseover', handleOtherNodeMouseover);
            }
          });
          
          self.classList.add('dragging-connectors');
          
          self.captureMouse(event, {
            mousemove: function(options) {
              if (!self.draggingConnectorNodes.via) {
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('viaPos', {
                    x: options.currentPosView.x + self.viewMargin,
                    y: options.currentPosView.y + self.viewMargin,
                  });
                });
              } else if(!self.draggingConnectorNodes.to) {
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('toPos', {
                    x: options.currentPosView.x + self.viewMargin,
                    y: options.currentPosView.y + self.viewMargin,
                  });
                });
              }
            },
            mouseup: function() {
            
              self.classList.remove('dragging-connectors');
            
              self.nodeWidgetsTopLevel.forEach(function(otherNodeWidget) {
                if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
                  otherNodeWidget.removeEventListener('mouseover', handleOtherNodeMouseover);
                }
              });
              
              if (self.draggingConnectorNodes.via &&
                  self.draggingConnectorNodes.to) {
                
                var newLinks = [];
                
                self.draggingConnectorNodes.from.forEach(function(fromNodeWidget) {
                  var nodeWidgetTriple = {
                    from: fromNodeWidget,
                    via:  self.draggingConnectorNodes.via,
                    to:   self.draggingConnectorNodes.to,
                  }
                  var connector = self.getConnectorForNodeWidgetTriple(nodeWidgetTriple);
                  if (connector) {
                    self.activateConnector(connector);
                  } else {
                    self.createConnector({
                      from: fromNodeWidget,
                      via:  self.draggingConnectorNodes.via,
                      to:   self.draggingConnectorNodes.to,
                    });
                  }
                  newLinks.push({
                    from: self.node_id.fromHex(fromNodeWidget.nodeId),
                    via:  self.node_id.fromHex(self.draggingConnectorNodes.via.nodeId),
                    to:   self.node_id.fromHex(self.draggingConnectorNodes.to.nodeId)
                  });
                });
                
                self.client.addLinks(newLinks);
              }
              
              self.draggingConnectors.forEach(function(draggingConnector) {
                Polymer.dom(self.viewRoot).removeChild(draggingConnector);
              });
              self.draggingConnectors = [];
            },
            blockEvents: false
          });
        },
        _setupNodeWidgetConnectorDragging: function(nodeWidget) {
          var self = this;
          
          nodeWidget.addEventListener('rightButtonDragStart', function(event) {
            event.preventDefault();
            
            if (self.nodeWidgetsTopLevel.has(nodeWidget)) {
            
              if (!self.selectedNodeWidgets.has(nodeWidget)) {
                self.selectNodeWidgets([nodeWidget]);
              }
              
              var nodePos = self.getNodePosition(nodeWidget);
              
              var cursorPos = {
                x: nodePos.x + event.detail.offsetX,
                y: nodePos.y + event.detail.offsetY,
              }
              
              self.startNewConnectorDragFromSelected(event.detail, cursorPos);
            }
          });
        },
        _setupNodeWidgetMenu: function(nodeWidget) {
          var self = this;
          
          if (!self.nodeWidgetsTopLevel.has(nodeWidget)) {
            return;
          }
          
          nodeWidget.addEventListener('contextMenu', function(event) {
            if (!self.draggingConnectors.length) {
              self.openSelectionMenu(event.detail);
            }
          });
        },
        createConnector: function(nodeWidgets, options) {
        
          var self = this;
        
          var connector = document.createElement('yb-connector');
          
          self.connectors.add(connector);
          
          options = options || {};
          
          connector.active = ('active' in options) ? options.active : true;
          
          if (connector.active) {
            self.activeConnectors.add(connector);
          } else {
            connector.classList.add('inactive');
          }
          
          connector.fromWidget = nodeWidgets.from;
          connector.viaWidget  = nodeWidgets.via;
          connector.toWidget   = nodeWidgets.to;
         
          nodeWidgets.from.connectorsFrom.add(connector);
          nodeWidgets.via.connectorsVia.add(connector);
          nodeWidgets.to.connectorsTo.add(connector);
          
          var linkKey = self.node_id.linkToKey({
            from: self.node_id.fromHex(nodeWidgets.from.nodeId),
            via:  self.node_id.fromHex(nodeWidgets.via.nodeId),
            to:   self.node_id.fromHex(nodeWidgets.to.nodeId),
          });
          if (self.linksToConnectors.has(linkKey)) {
            self.linksToConnectors.get(linkKey).add(connector);
          } else {
            self.linksToConnectors.set(linkKey, new Set([connector]));
          }
          
          var nodeWidgetsLinkKey = self.node_id.linkToKey({
            from: nodeWidgets.from.widgetId,
            via:  nodeWidgets.via.widgetId,
            to:   nodeWidgets.to.widgetId,
          });
          self.nodeWidgetsToConnectors.set(nodeWidgetsLinkKey, connector);
          
          if (!self.connectorsFrom.has(nodeWidgets.from)) {
            self.connectorsFrom.set(nodeWidgets.from, [connector]);
          } else {
            self.connectorsFrom.get(nodeWidgets.from).push(connector);
          }
          
          if (!self.connectorsVia.has(nodeWidgets.via)) {
            self.connectorsVia.set(nodeWidgets.via, [connector]);
          } else {
            self.connectorsVia.get(nodeWidgets.via).push(connector);
          }
          
          if (!self.connectorsTo.has(nodeWidgets.to)) {
            self.connectorsTo.set(nodeWidgets.to, [connector]);
          } else {
            self.connectorsTo.get(nodeWidgets.to).push(connector);
          }
          
          var fromCenter = self.getNodeWidgetCenter(nodeWidgets.from);
          var viaCenter  = self.getNodeWidgetCenter(nodeWidgets.via);
          var toCenter   = self.getNodeWidgetCenter(nodeWidgets.to);
          
          connector.set('fromPos', {
            x: fromCenter.x + self.viewMargin,
            y: fromCenter.y + self.viewMargin,
          });
          connector.set('viaPos', {
            x: viaCenter.x + self.viewMargin,
            y: viaCenter.y + self.viewMargin,
          });
          connector.set('toPos', {
            x: toCenter.x + self.viewMargin,
            y: toCenter.y + self.viewMargin,
          });
          
          self._setupConnectorHighlight(connector);
          self._setupConnectorSelection(connector);
          self._setupConnectorMenu(connector);
          
          Polymer.dom(self.viewRoot).appendChild(connector);
          
          return connector;
        },
        _setupConnectorHighlight: function(connector) {
          var self = this;
          connector.addEventListener('mouseover', function(event) {
            self.bringConnectorToFront(connector);
          });
        },
        _setupConnectorSelection: function(connector) {
          var self = this;
          connector.addEventListener('selected', function(event) {
            if (!self.selectedConnectors.has(connector)) {
              if (!event.detail.ctrlKey) {
                self.deselect();
              }
              self.selectedConnectors.add(connector);
              connector.set('selected', true);
            }
          });
        },
        _setupConnectorMenu: function(connector) {
          var self = this;
          connector.addEventListener('contextMenu', function(event) {
            self.openSelectionMenu(event.detail);
          });
        },
        activateConnector: function(connector, activate) {
          
          if (typeof activate === 'undefined') {
            activate = true;
          }
        
          if (activate && !connector.active) {
            connector.active = true;
            this.activeConnectors.add(connector);
            connector.classList.remove('inactive');
            if (connector.highlightAnimation) {
              console.log('cancelling connector highlight animation due to activation');
              connector.highlightAnimation.cancel();
              connector.highlightAnimation = null;
            }
          } else if (!activate && connector.active) {
            connector.active = false;
            this.activeConnectors.delete(connector);
            connector.classList.add('inactive');
            if (connector.highlightAnimation) {
              console.log('cancelling connector highlight animation due to deactivation');
              connector.highlightAnimation.cancel();
              connector.highlightAnimation = null;
            }
          }
        },
        updateConnectorsForNodeWidget: function(nodeWidget) {
          var self = this;
          
          var nodeCenter = self.getNodeWidgetCenter(nodeWidget);
          
          if (self.connectorsFrom.has(nodeWidget)) {
            var connectorsFrom = self.connectorsFrom.get(nodeWidget);
            connectorsFrom.forEach(function(connector) {
              connector.set('fromPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            });
          }
          if (self.connectorsVia.has(nodeWidget)) {
            var connectorsVia = self.connectorsVia.get(nodeWidget);
            connectorsVia.forEach(function(connector) {
              connector.set('viaPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            });
          }
          if (self.connectorsTo.has(nodeWidget)) {
            var connectorsTo = self.connectorsTo.get(nodeWidget);
            connectorsTo.forEach(function(connector) {
              connector.set('toPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            })
          }
        },
        createSetWidget: function(position) {
        
          var setWidget = document.createElement('yb-set');
          
          setWidget.style.position = 'absolute';
          setWidget.style.left = position.x + 'px';
          setWidget.style.top  = position.y + 'px';
          setWidget.position = position;
          
          this._setupSetWidgetSelection(setWidget);
          this._setupSetWidgetMenu(setWidget);
          this._setupSetWidgetDragging(setWidget);
          
          Polymer.dom(this.viewRoot).appendChild(setWidget);
          this.setWidgets.add(setWidget);
          
          return setWidget;
        },
        removeSetWidget: function(setWidget) {
          var self = this;
          if (self.selectedSetWidgets.has(setWidget)) {
            self.selectedSetWidgets.delete(setWidget);
          }
          self.setWidgets.delete(setWidget);
          setWidget.dragdropAreas.forEach(function(dragdropArea) {
            self.dragdropAreas.delete(dragdropArea);
          });
          Polymer.dom(self.viewRoot).removeChild(setWidget);
        },
        _setupSetWidgetSelection: function(setWidget) {
          var self = this;
          setWidget.addEventListener('selected', function(event) {
            if (event.target === setWidget) {
              if (!self.selectedSetWidgets.has(setWidget)) {
                if (!event.detail.ctrlKey) {
                  self.deselect();
                }
                self.selectedSetWidgets.add(setWidget);
                setWidget.set('selected', true);
              }
            } else if (self.nodeWidgets.has(event.target)) {
              if (!self.selectedNodeWidgets.has(event.target)) {
                self.selectNodeWidgets([event.target], event.detail.ctrlKey);
              }
            }
          });
        },
        _setupSetWidgetDragging: function(setWidget) {
          var self = this;
          setWidget.addEventListener('dragStart', function(event) {
            if (event.detail.target === setWidget.widgetHandle) {
              event.detail.preventDefault();
              if (event.detail.shiftKey) {
                self.copySelected();
              }
              self.startDraggingSelected(event);
              return false;
            }
          });
        },
        _setupSetWidgetMenu: function(setWidget) {
          var self = this;
          setWidget.addEventListener('contextMenu', function(event) {
            if (event.detail.target === setWidget.widgetHandle) {
              if (!self.draggingConnectors.length) {
              
                self.openSelectionMenu(event.detail);
              }
            }
          });
        },
        dragdropAreaAttached: function(event) {
          this.dragdropAreas.add(event.detail);
        },
        dragdropAreaDetached: function(event) {
          this.dragdropAreas.delete(event.detail);
        },
        openBackgroundMenu: function(position) {
          this.$.backgroundDropdown.style.position = 'absolute';
          this.$.backgroundDropdown.style.left = position.x + 'px';
          this.$.backgroundDropdown.style.top  = position.y + 'px';
          this.$.backgroundDropdown.style.display = 'block';
        },
        closeBackgroundMenu: function() {
          this.$.backgroundDropdown.style.display = 'none';
        },
        openSelectionMenu: function(event) {
          this.closeBackgroundMenu();
          
          var surfaceRect = this.getBoundingClientRect();
          this.$.selectionDropdown.style.position = 'absolute';
          this.$.selectionDropdown.style.left = (event.pageX - surfaceRect.left) + 'px';
          this.$.selectionDropdown.style.top  = (event.pageY - surfaceRect.top)  + 'px';
          this.$.selectionDropdown.style.display = 'block';
        },
        closeSelectionMenu() {
          this.$.selectionDropdown.style.display = 'none';
        },
        menuItem_CreateNode: function() {
          this.closeBackgroundMenu();
          this.createNodeWidget(this.lastMenuPosition);
        },
        menuItem_CreateSet: function() {
          this.closeBackgroundMenu();
          this.createSetWidget(this.lastMenuPosition);
        },
        menuItem_DeleteSelected: function() {
          var self = this;
          self.closeSelectionMenu();
          var linksToDelete = self.removeSelectedWidgets();
          self.client.removeLinks(linksToDelete);
        },
        menuItem_HideSelected: function() {
          this.closeSelectionMenu();
          this.removeSelectedWidgets();
        },
        menuItem_CopySelected: function() {
          this.closeSelectionMenu();
          var offset = 10;
          this.copySelected(offset);
        },
        menuItem_RevealLinks: function() {
          this.closeSelectionMenu();
          this.revealLinksBetweenNodeWidgets(this.selectedNodeWidgets, true);
        },
        menuItem_HideLinks: function() {
          var self = this;
          this.closeSelectionMenu();
          var connectors = new Set(Array.from(this.selectedConnectors).concat(this.getConnectorsBetweenNodeWidgets(this.selectedNodeWidgets)));
          connectors.forEach(function(connector) {
            self.hideConnector(connector);
          });
        },
      });
    })();
  </script>

</dom-module>