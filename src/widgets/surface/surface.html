<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-icon-item.html">

<link rel="import" href="../node/node.html">
<link rel="import" href="../connector/connector.html">
<link rel="import" href="../set/set.html">

<link rel="import" href="surface-styles.html">

<dom-module id="yb-surface">

  <style include="surface-styles"></style>

  <template>
  
    <div id="viewRoot">
    
      <div id="background" on-mousedown="backgroundMousedown" on-wheel="backgroundWheel"></div>
    
      <div id="boxSelection" class="hidden"></div>
    
    </div>
    
    <iron-dropdown id="backgroundDropdown" horizontal-align="left" vertical-align="top">
      <div class="dropdown-content">
        <paper-menu>
          <paper-icon-item on-tap="menuItem_CreateNode">
            <iron-icon icon="icons:add" item-icon></iron-icon>
            Add Node
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_CreateSet">
            <iron-icon icon="icons:add" item-icon></iron-icon>
            Add Set
          </paper-icon-item>
        </paper-menu>
      </div>
    </iron-dropdown>
    
    <iron-dropdown id="selectionDropdown" horizontal-align="left" vertical-align="top">
      <div class="dropdown-content">
        <paper-menu>
          <paper-icon-item on-tap="menuItem_CopySelected">
            <iron-icon icon="icons:content-copy" item-icon></iron-icon>
            Copy
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_RevealLinks">
            <iron-icon icon="icons:visibility" item-icon></iron-icon>
            Reveal Links
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_HideLinks">
            <iron-icon icon="icons:visibility-off" item-icon></iron-icon>
            Hide Links
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_HideSelected">
            <iron-icon icon="icons:visibility-off" item-icon></iron-icon>
            Hide
          </paper-icon-item>
          <paper-icon-item on-tap="menuItem_DeleteSelected">
            <iron-icon icon="icons:delete" item-icon></iron-icon>
            Delete
          </paper-icon-item>
        </paper-menu>
      </div>
    </iron-dropdown>
      
  </template>
  
  <script>
    (function() {
      'use strict';
      
      Polymer({
        is: 'yb-surface',
        created: function() {
          var self = this;
          
          self.viewTranslate = {x: 0, y: 0};
          self.viewScale     = 1.0;
          self.viewOrigin    = {x: 0, y: 0};
          
          self.viewMargin = 10000;
          
          self.nodeWidgets         = new Set();
          self.nodeWidgetsTopLevel = new Set();
          
          self.connectors = new Set();
          self.connectorsFrom = new Map();
          self.connectorsVia  = new Map();
          self.connectorsTo   = new Map();
          
          self.draggingConnectors = [];
          
          self.selectedNodeWidgets = new Set();
          self.selectedConnectors  = new Set();
          self.selectedSetWidgets  = new Set();
          
          self.setWidgets = new Set();
          
          self.dropTargets = new Set();
          
          require(['client', 'node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
          });
        },
        ready: function() {
        
          var self = this;
          
          self.viewRoot = self.$.viewRoot;
          
          self.setView(self.viewTranslate, self.viewScale, self.viewOrigin);
        
          require(['client', 'node_id'], function(client, node_id) {
            self.client  = client;
            self.node_id = node_id;
        
//             self.createNodeWidget({x: 100, y: 40},  '52f9cf0e223d559931856acc98400f21');
//             self.createNodeWidget({x: 100, y: 100}, '1264ed87a8274e5188f9020954811805');
//             self.createNodeWidget({x: 100, y: 160}, '5c4d67cf88fd9c5dbc841dee378b6b4b');
//             self.createNodeWidget({x: 185, y: 160}, '7e1b27583610201f8b48941d3637b13f');
            
//             self.createSetWidget({x: 400, y: 50});
          });
        },
        listeners: {
          contextmenu: 'oncontextmenu',
          nodeWidgetCreated:   'nodeWidgetCreated',
          nodeWidgetDestroyed: 'nodeWidgetDestroyed',
          dropTargetAttached: 'dropTargetAttached',
          dropTargetDetached: 'dropTargetDetached',
        },
        captureMouse: function(event, options) {
        
          var self = this;
        
          var cusorBeforeMouseCapture = document.body.style.cursor;
          
          if ('cursor' in options) {
            document.body.style.cursor = options.cursor;
          }
          
          var startPosPage = {
            x: event.pageX,
            y: event.pageY,
          }
          
          var eventTargetRectView = self.getElementRectInView(event.target);
          
          var startPosView = {
            x: eventTargetRectView.left + event.offsetX,
            y: eventTargetRectView.top  + event.offsetY,
          }
          
          var lastPosPage = startPosPage;
          var lastPosView = startPosView;
          
          self.classList.add('mouse-captured');
          
          self.$.background.addEventListener('mousemove', mousemove);
          
          function mousemove(event) {
          
            event.stopImmediatePropagation();
          
            var currentPosPage = {
              x: event.pageX,
              y: event.pageY,
            }
          
            var currentPosView = {
              x: event.offsetX - self.viewMargin,
              y: event.offsetY - self.viewMargin,
            }
          
            var dragDeltaView = {
              x: (event.offsetX - self.viewMargin) - startPosView.x,
              y: (event.offsetY - self.viewMargin) - startPosView.y,
            }
            
            var dragDeltaPage = {
              x: event.pageX - startPosPage.x,
              y: event.pageY - startPosPage.y,
            }
            
            var currentDeltaPage = {
              x: currentPosPage.x - lastPosPage.x,
              y: currentPosPage.y - lastPosPage.y,
            }
            
            var currentDeltaView = {
              x: currentPosView.x - lastPosView.x,
              y: currentPosView.y - lastPosView.y,
            }
          
            if ('mousemove' in options) {
              options.mousemove({
                event: event,
                currentPosPage: currentPosPage,
                currentPosView: currentPosView,
                dragDeltaPage: dragDeltaPage,
                dragDeltaView: dragDeltaView,
                currentDeltaPage: currentDeltaPage,
                currentDeltaView: currentDeltaView,
              });
            }
            
            lastPosPage = currentPosPage;
            lastPosView = currentPosView;
          }
          
          function mouseup(event) {
          
            self.$.background.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup',   mouseup);
            
            document.body.style.cursor = cusorBeforeMouseCapture;
          
            self.classList.remove('mouse-captured');
            
            if ('mouseup' in options) {
              options.mouseup(event);
            }
          }
          
          window.addEventListener('mouseup',   mouseup);
        },
        startViewDrag: function(event) {
          var self = this;
          event.preventDefault();
          self.captureMouse(event, {
            cursor: '-webkit-grabbing',
            mousemove: function(options) {
              self.moveView(options.currentDeltaPage);
            }
          });
          return false;
        },
        setView: function(translate, scale, origin) {
          this.viewTranslate = translate;
          this.viewScale     = scale;
          this.viewOrigin    = origin;
          this.viewRoot.style.transform = 'translate(' + translate.x + 'px, ' + translate.y + 'px) scale(' + scale + ')';
          this.viewRoot.style['transform-origin'] = origin.x + 'px ' + origin.y + 'px';
        },
        moveView: function(offset) {
          this.setView({
              x: this.viewTranslate.x + offset.x,
              y: this.viewTranslate.y + offset.y,
            },
            this.viewScale,
            this.viewOrigin
          );
        },
        zoomView: function(scaleMultiplier) {
          this.setView(this.viewTranslate, this.viewScale * scaleMultiplier, this.viewOrigin);
        },
        zoomOnPosition: function(position, zoomOffset) {
          this.setView(
            {
              x: this.viewTranslate.x + ((position.x - this.viewOrigin.x) * (this.viewScale - 1.0)),
              y: this.viewTranslate.y + ((position.y - this.viewOrigin.y) * (this.viewScale - 1.0)),
            },
            this.viewScale * (1.0 + zoomOffset),
            {
              x: position.x,
              y: position.y,
            }
          );
        },
        oncontextmenu: function(event) {
          event.preventDefault();
          return false;
        },
        backgroundMousedown: function(event) {
        
          this.closeSelectionMenu();
          
          if (!event.ctrlKey) {
            this.deselect();
          }
          
          var cursorPosition = {
            x: event.offsetX - this.viewMargin,
            y: event.offsetY - this.viewMargin,
          }
        
          if (event.button === 0) {
          
            this.closeBackgroundMenu();

            return this.startBoxSelection(event);
            
          } else if (event.button === 1) {
          
            return this.startViewDrag(event);
            
          } else if (event.button === 2) {
          
            this.lastMenuPosition = cursorPosition;
          
            var surfaceRect = this.getBoundingClientRect();
          
            this.openBackgroundMenu({
              x: event.pageX - surfaceRect.left,
              y: event.pageY - surfaceRect.top,
            });
            return false;
          }
        },
        backgroundWheel: function(event) {
          
          var cursorPosView = {
            x: event.offsetX - this.viewMargin,
            y: event.offsetY - this.viewMargin,
          }
          
          var zoomSpeed = null;
          if (event.deltaMode === 0) { // Pixels
            zoomSpeed = 0.08;
          } else if (event.deltaMode === 1) { // Lines
            zoomSpeed = 0.16;
          } else if (event.deltaMode === 2) { // Pages
            zoomSpeed = 0.2;
          } else {
            zoomSpeed = 0.08;
          }
          
          var zoomOffset = (event.deltaY < 0) ? zoomSpeed : -zoomSpeed;
          
          this.zoomOnPosition(cursorPosView, zoomOffset);
        },
        startBoxSelection: function(event) {
        
          event.preventDefault();
        
          var self = this;
          
          var dragStartOffset = {
            x: event.offsetX + self.$.background.offsetLeft,
            y: event.offsetY + self.$.background.offsetTop,
          }
          
          self.$.boxSelection.style.left = dragStartOffset.x + 'px';
          self.$.boxSelection.style.top  = dragStartOffset.y + 'px';
          self.$.boxSelection.style.width  = '0';
          self.$.boxSelection.style.height = '0';
          
          self.$.boxSelection.classList.remove('hidden');
          
          var alreadySelectedNodeWidgets = new Set(self.selectedNodeWidgets);
          var alreadySelectedSetWidgets  = new Set(self.selectedSetWidgets);
          
          self.captureMouse(event, {
            cursor: 'crosshair',
            mousemove: function(options) {
            
              var currentSelectionRect = {
                left:   Math.min(dragStartOffset.x, dragStartOffset.x + options.dragDeltaView.x),
                top:    Math.min(dragStartOffset.y, dragStartOffset.y + options.dragDeltaView.y),
                right:  Math.max(dragStartOffset.x, dragStartOffset.x + options.dragDeltaView.x),
                bottom: Math.max(dragStartOffset.y, dragStartOffset.y + options.dragDeltaView.y),
              }
              
              self.$.boxSelection.style.left   = currentSelectionRect.left + 'px';
              self.$.boxSelection.style.top    = currentSelectionRect.top  + 'px';
              self.$.boxSelection.style.width  = (currentSelectionRect.right  - currentSelectionRect.left) + 'px';
              self.$.boxSelection.style.height = (currentSelectionRect.bottom - currentSelectionRect.top)  + 'px';
              
              var nodesToSelect = new Set(self.getNodeWidgetsInRect(currentSelectionRect));
              alreadySelectedNodeWidgets.forEach(function(nodeWidget) {
                nodesToSelect.add(nodeWidget);
              });
              self.selectNodeWidgets(nodesToSelect);
              
              var setWidgetsToSelect = new Set(self.getSetWidgetsInRect(currentSelectionRect));
              alreadySelectedSetWidgets.forEach(function(nodeWidget) {
                setWidgetsToSelect.add(nodeWidget);
              });
              self.selectSetWidgets(setWidgetsToSelect);
            },
            mouseup: function(event) {
              self.$.boxSelection.classList.add('hidden');
            }
          });
          
          return false;
        },
        getElementRectInView: function(element) {
          if (!element.offsetParent || (element.offsetParent === this.viewRoot)) {
            return {
              left:   element.offsetLeft,
              top:    element.offsetTop,
              right:  element.offsetLeft + element.offsetWidth,
              bottom: element.offsetTop  + element.offsetHeight,
              width:  element.offsetWidth,
              height: element.offsetHeight,
            }
          } else {
            var offsetParentRect = this.getElementRectInView(element.offsetParent);
            return {
              left:   offsetParentRect.left + element.offsetLeft,
              top:    offsetParentRect.top  + element.offsetTop,
              right:  offsetParentRect.left + element.offsetLeft + element.offsetWidth,
              bottom: offsetParentRect.top  + element.offsetTop  + element.offsetHeight,
              width:  element.offsetWidth,
              height: element.offsetHeight,
            }
          }
        },
        getNodePosition: function(nodeWidget) {
          var nodeRect = this.getNodeWidgetRect(nodeWidget);
          return {
            x: nodeRect.left,
            y: nodeRect.top,
          }
        },
        getNodeWidgetCenter: function(nodeWidget) {
          var nodeRect = this.getNodeWidgetRect(nodeWidget);
          return {
            x: nodeRect.left + (nodeRect.width  / 2),
            y: nodeRect.top  + (nodeRect.height / 2),
          }
        },
        getNodeWidgetRect: function(nodeWidget) {
          return this.getElementRectInView(nodeWidget);
        },
        getNodeWidgetsInRect: function(rect) {
          var self = this;
          return Array.from(self.nodeWidgets).filter(function(nodeWidget) {
            var nodeRect = self.getNodeWidgetRect(nodeWidget);
            return !(nodeRect.left > rect.right  || nodeRect.right  < rect.left ||
                     nodeRect.top  > rect.bottom || nodeRect.bottom < rect.top);
          });
        },
        getSetWidgetsInRect: function(rect) {
          return Array.from(this.setWidgets).filter(function(setWidget) {
            var setClientRect = setWidget.widgetHandle.getBoundingClientRect();
            var setRect = {
              left:   setWidget.position.x,
              top:    setWidget.position.y,
              right:  setWidget.position.x + setClientRect.width,
              bottom: setWidget.position.y + setClientRect.height,
            }
            return !(setRect.left > rect.right  || setRect.right  < rect.left ||
                     setRect.top  > rect.bottom || setRect.bottom < rect.top);
          });
        },
        startDraggingSelected: function(event, copy) {
          var self = this;
          
          if (copy || event.detail.shiftKey) {
            self.copySelected();
          }
        
          var cursorStartPos = {
            x: event.detail.pageX,
            y: event.detail.pageY,
          }
          
          var draggingNodeWidgets = new Set(Array.from(self.selectedNodeWidgets).filter(function(nodeWidget) {
            return self.nodeWidgetsTopLevel.has(nodeWidget);
          }));
          
          draggingNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.dragStartPosition = self.getNodePosition(nodeWidget);
            nodeWidget.classList.add('dragging');
          });
          
          self.selectedSetWidgets.forEach(function(setWidget) {
            setWidget.dragStartPosition = setWidget.position;
          });
          
          self.classList.add('dragging-nodes');
          
          self.captureMouse(event.detail, {
            cursor: '-webkit-grabbing',
            mousemove: function(options) {
            
              draggingNodeWidgets.forEach(function(draggingNodeWidget) {
              
                var newPos = {
                  x: draggingNodeWidget.dragStartPosition.x + options.dragDeltaView.x,
                  y: draggingNodeWidget.dragStartPosition.y + options.dragDeltaView.y,
                }
                
                draggingNodeWidget.style.left = newPos.x + 'px';
                draggingNodeWidget.style.top  = newPos.y + 'px';
              
                self.updateConnectorsForNodeWidget(draggingNodeWidget);
              });
              
              self.selectedSetWidgets.forEach(function(selectedSetWidget) {
                
                var newPos = {
                  x: selectedSetWidget.dragStartPosition.x + options.dragDeltaView.x,
                  y: selectedSetWidget.dragStartPosition.y + options.dragDeltaView.y,
                }
                
                selectedSetWidget.style.left = newPos.x + 'px';
                selectedSetWidget.style.top  = newPos.y + 'px';
                selectedSetWidget.position = newPos;
              });
              
              return false;
            },
            mouseup: function() {
            
              self.classList.remove('dragging-nodes');
          
              draggingNodeWidgets.forEach(function(nodeWidget) {
                nodeWidget.classList.remove('dragging');
              });
              
              self.dropTargets.forEach(function(dropTarget) {
                dropTarget.removeEventListener('mouseover', dropTargetMouseover);
                dropTarget.removeEventListener('mouseout',  dropTargetMouseout);
                dropTarget.removeEventListener('mouseup',   dropTargetMouseup);
                dropTarget.classList.remove('drag-ready');
              });
            }
          });
          
          function dropTargetMouseover(event) {
            var dropTarget = event.currentTarget;
            dropTarget.classList.add('drag-hover');
          }
          function dropTargetMouseout(event) {
            var dropTarget = event.currentTarget;
            dropTarget.classList.remove('drag-hover');
          }
          function dropTargetMouseup(event) {
            var dropTarget = event.currentTarget;
            dropTarget.classList.remove('drag-hover');
            dropTarget.fire('nodes-dropped', draggingNodeWidgets);
            draggingNodeWidgets.forEach(function(nodeWidget) {
              nodeWidget.style.left = nodeWidget.dragStartPosition.x + 'px';
              nodeWidget.style.top  = nodeWidget.dragStartPosition.y + 'px';
              self.updateConnectorsForNodeWidget(nodeWidget);
            });
            this.updateStyles();
          }
          
          self.dropTargets.forEach(function(dropTarget) {
            if (dropTarget.enabled) {
              dropTarget.addEventListener('mouseover', dropTargetMouseover);
              dropTarget.addEventListener('mouseout',  dropTargetMouseout);
              dropTarget.addEventListener('mouseup',   dropTargetMouseup);
              dropTarget.classList.add('drag-ready');
            }
          });
        },
        createNodeWidget: function(position, id) {
        
          var self = this;
        
          var nodeWidget = document.createElement('yb-node');
          if (!id) {
            id = self.node_id.makeHex();
          }
          nodeWidget.nodeId = id;
          nodeWidget.style.position = 'absolute';
          nodeWidget.style.left = position.x + 'px';
          nodeWidget.style.top  = position.y + 'px';
          
          nodeWidget.addEventListener('dimensionsChanged', function(event) {
            self.updateConnectorsForNodeWidget(nodeWidget);
          });
          
          self.nodeWidgetsTopLevel.add(nodeWidget);
          
          Polymer.dom(self.viewRoot).appendChild(nodeWidget);
          
          return nodeWidget;
        },
        nodeWidgetCreated: function(event) {
          var nodeWidget = event.detail;
          if (!this.nodeWidgets.has(nodeWidget)) {
            this.nodeWidgets.add(nodeWidget);
            this._setupNodeWidgetHighlighting(nodeWidget);
            this._setupNodeWidgetSelection(nodeWidget);
            this._setupNodeWidgetDragging(nodeWidget);
            this._setupNodeWidgetConnectorDragging(nodeWidget);
            this._setupNodeWidgetMenu(nodeWidget);
          }
        },
        nodeWidgetDestroyed: function(event) {
          var nodeWidget = event.detail;
          
          this.nodeWidgets.delete(nodeWidget);
          
          if (this.nodeWidgetsTopLevel.has(nodeWidget)) {
            this.nodeWidgetsTopLevel.delete(nodeWidget);
          }
          
          if (this.selectedNodeWidgets.has(nodeWidget)) {
            this.selectedNodeWidgets.delete(nodeWidget);
          }
        },
        _setupNodeWidgetHighlighting: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('mouseover', function(event) {
            var nodeCopies = [];
            self.nodeWidgets.forEach(function(otherNodeWidget) {
              if (otherNodeWidget !== nodeWidget && otherNodeWidget.nodeId === nodeWidget.nodeId) {
                nodeCopies.push(otherNodeWidget);
                otherNodeWidget.set('highlighted', true);
              }
            });
            function stopHighlighting() {
              nodeWidget.removeEventListener('mouseout', stopHighlighting);
              nodeWidget.removeEventListener('detached', stopHighlighting);
              nodeCopies.forEach(function(nodeWidgetCopy) {
                nodeWidgetCopy.set('highlighted', false);
              });
            }
            nodeWidget.addEventListener('mouseout', stopHighlighting);
            nodeWidget.addEventListener('detached', stopHighlighting);
          });
        },
        _setupNodeWidgetSelection: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('selected', function(event) {
            if (!self.selectedNodeWidgets.has(nodeWidget)) {
              self.selectNodeWidgets([nodeWidget], event.detail.ctrlKey);
            }
          });
        },
        bringNodeWidgetToFront: function(nodeWidget) {
          if (this.nodeWidgetsTopLevel.has(nodeWidget)) {
            Polymer.dom(this.viewRoot).appendChild(nodeWidget);
          }
        },
        bringConnectorToFront: function(connector) {
          Polymer.dom(this.viewRoot).appendChild(connector);
        },
        bringSetWidgetToFront: function(setWidget) {
          Polymer.dom(this.viewRoot).appendChild(setWidget);
        },
        selectNodeWidgets: function(nodeWidgets, appendSelection) {
          var self = this;
          
          nodeWidgets = new Set(nodeWidgets);
        
          if (!appendSelection) {
            self.selectedNodeWidgets.forEach(function(nodeWidget) {
              if (!nodeWidgets.has(nodeWidget)) {
                nodeWidget.set('selected', false);
              }
            });
          }
          
          nodeWidgets.forEach(function(nodeWidget) {
            if (!self.selectedNodeWidgets.has(nodeWidget)) {
              nodeWidget.set('selected', true);
              if (appendSelection) {
                self.selectedNodeWidgets.add(nodeWidget);
              }
            }
          });
          
          if (!appendSelection) {
          
            self.selectedNodeWidgets = new Set(nodeWidgets);
            
            self.selectedConnectors.forEach(function(connector) {
              connector.set('selected', false);
            });
            self.selectedConnectors.clear();
            
            self.selectedSetWidgets.forEach(function(setWidget) {
              setWidget.set('selected', false);
            });
            self.selectedSetWidgets.clear();
          }
        },
        selectSetWidgets: function(setWidgets) {
          this.selectedSetWidgets.forEach(function(setWidget) {
            if (!setWidgets.has(setWidget)) {
              setWidget.set('selected', false);
            }
          });
          
          setWidgets.forEach(function(setWidget) {
            setWidget.set('selected', true);
          });
          
          this.selectedSetWidgets = new Set(setWidgets);
        },
        deselect: function() {
          this.selectedNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.set('selected', false);
          });
          this.selectedNodeWidgets.clear();
          
          this.selectedConnectors.forEach(function(connector) {
            connector.set('selected', false);
          });
          this.selectedConnectors.clear();
          
          this.selectedSetWidgets.forEach(function(setWidget) {
            setWidget.set('selected', false);
          });
          this.selectedSetWidgets.clear();
        },
        removeSelectedWidgets: function() {
          var self = this;
          
          var connectorsToDelete = new Set(self.selectedConnectors);
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            nodeWidget.connectors().forEach(function(connector) {
              connectorsToDelete.add(connector);
            });
          });
          
          // Delete node widgets
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            self.nodeWidgetDestroyed(nodeWidget);
            Polymer.dom(self.viewRoot).removeChild(nodeWidget);
          });
          self.nodeWidgets = new Set(Array.from(self.nodeWidgets).filter(function(nodeWidget) {
            return !self.selectedNodeWidgets.has(nodeWidget);
          }));
          self.nodeWidgetsTopLevel = new Set(Array.from(self.nodeWidgetsTopLevel).filter(function(nodeWidget) {
            return !self.selectedNodeWidgets.has(nodeWidget);
          }));
          self.selectedNodeWidgets.clear();
          
          connectorsToDelete.forEach(function(connector) {
            connector.fromWidget.connectorsFrom.delete(connector);
            connector.viaWidget.connectorsVia.delete(connector);
            connector.toWidget.connectorsTo.delete(connector);
            Polymer.dom(self.viewRoot).removeChild(connector);
          });
          
          // Find affected links
          var affectedLinks = new Set();
          self.selectedConnectors.forEach(function(connector) {
            affectedLinks.add(self.node_id.linkToKey({
              from: self.node_id.fromHex(connector.fromWidget.nodeId),
              via:  self.node_id.fromHex(connector.viaWidget.nodeId),
              to:   self.node_id.fromHex(connector.toWidget.nodeId)
            }));
          });
          
          // Delete connectors
          self.connectors = new Set(Array.from(self.connectors).filter(function(connector) {
            return !connectorsToDelete.has(connector);
          }));
          self.selectedConnectors.clear();
          
          // Delete set widgets
          var setWidgetsToDelete = new Set(self.selectedSetWidgets);
          setWidgetsToDelete.forEach(function(setWidget) {
            self.removeSetWidget(setWidget);
          });
          
          return affectedLinks;
        },
        removeConnector: function(connector) {
          connector.fromWidget.connectorsFrom.delete(connector);
          connector.viaWidget.connectorsVia.delete(connector);
          connector.toWidget.connectorsTo.delete(connector);
          Polymer.dom(this.viewRoot).removeChild(connector);
          this.connectors.delete(connector);
        },
        removeSelectedConnectors: function() {
          var self = this;
          self.selectedConnectors.forEach(function(connector) {
            connector.fromWidget.connectorsFrom.delete(connector);
            connector.viaWidget.connectorsVia.delete(connector);
            connector.toWidget.connectorsTo.delete(connector);
            Polymer.dom(self.viewRoot).removeChild(connector);
            self.connectors.delete(connector);
          });
          self.selectedConnectors.clear();
        },
        removeConnectorsBetweenSelectedNodeWidgets: function() {
          var self = this;
          self.connectors = new Set(Array.from(self.connectors).filter(function(connector) {
            if (self.selectedNodeWidgets.has(connector.fromWidget) &&
                self.selectedNodeWidgets.has(connector.viaWidget) &&
                self.selectedNodeWidgets.has(connector.toWidget)) {
              
              self.removeConnector(connector);
              return false;
            } else {
              return true;
            }
          }))
        },
        copySelected: function(offset) {
          var self = this;
          
          var newNodeWidgets = new Set();
          var newConnectors  = new Set();
          var newSetWidgets  = new Set();
          
          var oldToNewNodeWidgetMap = new Map();
          
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
          
            var nodePos = self.getNodePosition(nodeWidget);
            
            var newPosition = {
              x: nodePos.x + (offset || 0),
              y: nodePos.y + (offset || 0),
            }
            
            var newNodeWidget = self.createNodeWidget(newPosition, nodeWidget.nodeId);
            newNodeWidgets.add(newNodeWidget);
            
            nodeWidget.set('selected', false);
            newNodeWidget.set('selected', true);
            
            oldToNewNodeWidgetMap.set(nodeWidget, newNodeWidget);
          });
          
          self.selectedConnectors.forEach(function(connector) {
            
            if (self.selectedNodeWidgets.has(connector.fromWidget) &&
                self.selectedNodeWidgets.has(connector.viaWidget) &&
                self.selectedNodeWidgets.has(connector.toWidget)) {
              
              var newConnector = self.createConnector(
                oldToNewNodeWidgetMap.get(connector.fromWidget),
                oldToNewNodeWidgetMap.get(connector.viaWidget),
                oldToNewNodeWidgetMap.get(connector.toWidget)
              );
              newConnectors.add(newConnector);
              
              connector.set('selected', false);
              newConnector.set('selected', true);
            }
          });
          
          self.selectedSetWidgets.forEach(function(setWidget) {
          
            var newPosition = {
              x: setWidget.position.x + (offset || 0),
              y: setWidget.position.y + (offset || 0),
            }
          
            var newSetWidget = self.createSetWidget(newPosition);
            newSetWidget.set('from', setWidget.from);
            newSetWidget.set('via',  setWidget.via);
            newSetWidget.set('to',   setWidget.to);
            
            newSetWidgets.add(newSetWidget);
            
            setWidget.set('selected', false);
            newSetWidget.set('selected', true);
          });
          
          self.selectedNodeWidgets = newNodeWidgets;
          self.selectedConnectors  = newConnectors;
          self.selectedSetWidgets  = newSetWidgets;
        },
        revealLinksInSelected: function() {
        
          var self = this;
          
          var selectedNodeIdsToWidgets = new Map();
          self.selectedNodeWidgets.forEach(function(nodeWidget) {
            var nodeIdKey = self.node_id.toMapKey(self.node_id.fromHex(nodeWidget.nodeId));
            if (selectedNodeIdsToWidgets.has(nodeIdKey)) {
              selectedNodeIdsToWidgets.get(nodeIdKey).add(nodeWidget);
            } else {
              selectedNodeIdsToWidgets.set(nodeIdKey, new Set([nodeWidget]));
            }
          });
          
          self.client.web.getLinks().forEach(function(link) {
            if (selectedNodeIdsToWidgets.has(self.node_id.toMapKey(link.from)) &&
                selectedNodeIdsToWidgets.has(self.node_id.toMapKey(link.via)) &&
                selectedNodeIdsToWidgets.has(self.node_id.toMapKey(link.to))) {
              
              var nodeWidgetsFrom = selectedNodeIdsToWidgets.get(self.node_id.toMapKey(link.from));
              var nodeWidgetsVia  = selectedNodeIdsToWidgets.get(self.node_id.toMapKey(link.via));
              var nodeWidgetsTo   = selectedNodeIdsToWidgets.get(self.node_id.toMapKey(link.to));
              
              nodeWidgetsFrom.forEach(function(nodeWidgetFrom) {
                nodeWidgetsVia.forEach(function(nodeWidgetVia) {
                  nodeWidgetsTo.forEach(function(nodeWidgetTo) {
                    
                    var alreadyHasConnector = Array.from(self.connectors).some(function(connector) {
                      return connector.fromWidget === nodeWidgetFrom &&
                             connector.viaWidget  === nodeWidgetVia &&
                             connector.toWidget   === nodeWidgetTo;
                    });
                  
                    if (!alreadyHasConnector) {
                      self.createConnector(nodeWidgetFrom, nodeWidgetVia, nodeWidgetTo);
                    }
                  });
                });
              });
            }
          });
        },
        _setupNodeWidgetDragging: function(nodeWidget) {
          var self = this;
          nodeWidget.addEventListener('dragStart', function(event) {
            event.preventDefault();
            var copy = !self.nodeWidgetsTopLevel.has(event.target);
            self.startDraggingSelected(event, copy);
            return false;
          });
        },
        startNewConnectorDragFromSelected: function(event, dragStartPos) {
          var self = this;
          
          self.draggingConnectorNodes = {
            from: new Set(self.selectedNodeWidgets),
            via:  null,
            to:   null,
          }
          
          self.draggingConnectors = [];
          self.draggingConnectorNodes.from.forEach(function(fromNodeWidget) {
            var draggingConnector = document.createElement('yb-connector');
            draggingConnector.classList.add('not-clickable');
            var nodeCenter = self.getNodeWidgetCenter(fromNodeWidget);
            draggingConnector.set('fromPos', {
              x: nodeCenter.x + self.viewMargin,
              y: nodeCenter.y + self.viewMargin,
            });
            Polymer.dom(self.viewRoot).appendChild(draggingConnector);
            self.draggingConnectors.push(draggingConnector);
          });
          
          function handleOtherNodeMouseover(event) {
            var otherNodeWidget = event.currentTarget;
            var otherNodeCenter = self.getNodeWidgetCenter(otherNodeWidget);
            if (!self.draggingConnectorNodes.via) {
              if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
                self.draggingConnectorNodes.via = otherNodeWidget;
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('viaPos', {
                    x: otherNodeCenter.x + self.viewMargin,
                    y: otherNodeCenter.y + self.viewMargin,
                  });
                });
              }
            } else if (!self.draggingConnectorNodes.to) {
              if (otherNodeWidget !== self.draggingConnectorNodes.via) {
                self.draggingConnectorNodes.to = otherNodeWidget;
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('toPos', {
                    x: otherNodeCenter.x + self.viewMargin,
                    y: otherNodeCenter.y + self.viewMargin,
                  });
                });
              }
            }
          }
          
          self.nodeWidgetsTopLevel.forEach(function(otherNodeWidget) {
            if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
              otherNodeWidget.addEventListener('mouseover', handleOtherNodeMouseover);
            }
          });
          
          self.classList.add('dragging-connectors');
          
          self.captureMouse(event, {
            mousemove: function(options) {
              if (!self.draggingConnectorNodes.via) {
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('viaPos', {
                    x: options.currentPosView.x + self.viewMargin,
                    y: options.currentPosView.y + self.viewMargin,
                  });
                });
              } else if(!self.draggingConnectorNodes.to) {
                self.draggingConnectors.forEach(function(draggingConnector) {
                  draggingConnector.set('toPos', {
                    x: options.currentPosView.x + self.viewMargin,
                    y: options.currentPosView.y + self.viewMargin,
                  });
                });
              }
            },
            mouseup: function() {
            
              self.classList.remove('dragging-connectors');
            
              self.nodeWidgetsTopLevel.forEach(function(otherNodeWidget) {
                if (!self.draggingConnectorNodes.from.has(otherNodeWidget)) {
                  otherNodeWidget.removeEventListener('mouseover', handleOtherNodeMouseover);
                }
              });
              
              if (self.draggingConnectorNodes.via &&
                  self.draggingConnectorNodes.to) {
                
                self.draggingConnectorNodes.from.forEach(function(fromNodeWidget) {
                  self.createConnector(fromNodeWidget,
                                       self.draggingConnectorNodes.via,
                                       self.draggingConnectorNodes.to);
                  self.client.setLink({
                    from: self.node_id.fromHex(fromNodeWidget.nodeId),
                    via:  self.node_id.fromHex(self.draggingConnectorNodes.via.nodeId),
                    to:   self.node_id.fromHex(self.draggingConnectorNodes.to.nodeId)
                  });
                });
              }
              
              self.draggingConnectors.forEach(function(draggingConnector) {
                Polymer.dom(self.viewRoot).removeChild(draggingConnector);
              });
              self.draggingConnectors = [];
            },
            blockEvents: false
          });
        },
        _setupNodeWidgetConnectorDragging: function(nodeWidget) {
          var self = this;
          
          if (!self.nodeWidgetsTopLevel.has(nodeWidget)) {
            return;
          }
        
          nodeWidget.addEventListener('rightButtonDragStart', function(event) {
            event.preventDefault();
            
            if (!self.selectedNodeWidgets.has(nodeWidget)) {
              self.selectNodeWidgets([nodeWidget]);
            }
            
            var nodePos = self.getNodePosition(nodeWidget);
            
            var cursorPos = {
              x: nodePos.x + event.detail.offsetX,
              y: nodePos.y + event.detail.offsetY,
            }
            
            self.startNewConnectorDragFromSelected(event.detail, cursorPos);
          });
        },
        _setupNodeWidgetMenu: function(nodeWidget) {
          var self = this;
          
          if (!self.nodeWidgetsTopLevel.has(nodeWidget)) {
            return;
          }
          
          nodeWidget.addEventListener('contextMenu', function(event) {
            if (!self.draggingConnectors.length) {
              self.openSelectionMenu(event.detail);
            }
          });
        },
        createConnector: function(fromWidget, viaWidget, toWidget) {
        
          var self = this;
        
          var connector = document.createElement('yb-connector');
          Polymer.dom(self.viewRoot).appendChild(connector);
          
          connector.fromWidget = fromWidget;
          connector.viaWidget  = viaWidget;
          connector.toWidget   = toWidget;
          
          fromWidget.connectorsFrom.add(connector);
          viaWidget.connectorsVia.add(connector);
          toWidget.connectorsTo.add(connector);
          
          self.connectors.add(connector);
          
          if (!self.connectorsFrom.has(fromWidget)) {
            self.connectorsFrom.set(fromWidget, [connector]);
          } else {
            self.connectorsFrom.get(fromWidget).push(connector);
          }
          
          if (!self.connectorsVia.has(viaWidget)) {
            self.connectorsVia.set(viaWidget, [connector]);
          } else {
            self.connectorsVia.get(viaWidget).push(connector);
          }
          
          if (!self.connectorsTo.has(toWidget)) {
            self.connectorsTo.set(toWidget, [connector]);
          } else {
            self.connectorsTo.get(toWidget).push(connector);
          }
          
          var fromCenter = self.getNodeWidgetCenter(fromWidget);
          var viaCenter  = self.getNodeWidgetCenter(viaWidget);
          var toCenter   = self.getNodeWidgetCenter(toWidget);
          
          connector.set('fromPos', {
            x: fromCenter.x + self.viewMargin,
            y: fromCenter.y + self.viewMargin,
          });
          connector.set('viaPos', {
            x: viaCenter.x + self.viewMargin,
            y: viaCenter.y + self.viewMargin,
          });
          connector.set('toPos', {
            x: toCenter.x + self.viewMargin,
            y: toCenter.y + self.viewMargin,
          });
          
          connector.addEventListener('mouseover', function(event) {
            self.bringConnectorToFront(connector);
          });
          
          connector.addEventListener('selected', function(event) {
            if (!self.selectedConnectors.has(connector)) {
              if (!event.detail.ctrlKey) {
                self.deselect();
              }
              self.selectedConnectors.add(connector);
              connector.set('selected', true);
            }
          });
          
          connector.addEventListener('contextMenu', function(event) {
            self.openSelectionMenu(event.detail);
          });
          
          return connector;
        },
        updateConnectorsForNodeWidget: function(nodeWidget) {
          var self = this;
          
          var nodeCenter = self.getNodeWidgetCenter(nodeWidget);
          
          if (self.connectorsFrom.has(nodeWidget)) {
            var connectorsFrom = self.connectorsFrom.get(nodeWidget);
            connectorsFrom.forEach(function(connector) {
              connector.set('fromPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            });
          }
          if (self.connectorsVia.has(nodeWidget)) {
            var connectorsVia = self.connectorsVia.get(nodeWidget);
            connectorsVia.forEach(function(connector) {
              connector.set('viaPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            });
          }
          if (self.connectorsTo.has(nodeWidget)) {
            var connectorsTo = self.connectorsTo.get(nodeWidget);
            connectorsTo.forEach(function(connector) {
              connector.set('toPos', {
                x: nodeCenter.x + self.viewMargin,
                y: nodeCenter.y + self.viewMargin,
              });
            })
          }
        },
        createSetWidget: function(position) {
        
          var setWidget = document.createElement('yb-set');
          
          setWidget.style.position = 'absolute';
          setWidget.style.left = position.x + 'px';
          setWidget.style.top  = position.y + 'px';
          setWidget.position = position;
          
          this._setupSetWidgetSelection(setWidget);
          this._setupSetWidgetMenu(setWidget);
          this._setupSetWidgetDragging(setWidget);
          
          Polymer.dom(this.viewRoot).appendChild(setWidget);
          this.setWidgets.add(setWidget);
          
          return setWidget;
        },
        removeSetWidget: function(setWidget) {
          var self = this;
          if (self.selectedSetWidgets.has(setWidget)) {
            self.selectedSetWidgets.delete(setWidget);
          }
          self.setWidgets.delete(setWidget);
          setWidget.dropTargets.forEach(function(dropTarget) {
            self.dropTargets.delete(dropTarget);
          });
          Polymer.dom(self.viewRoot).removeChild(setWidget);
        },
        _setupSetWidgetSelection: function(setWidget) {
          var self = this;
          setWidget.addEventListener('selected', function(event) {
            if (event.target === setWidget) {
              if (!self.selectedSetWidgets.has(setWidget)) {
                if (!event.detail.ctrlKey) {
                  self.deselect();
                }
                self.selectedSetWidgets.add(setWidget);
                setWidget.set('selected', true);
              }
            } else if (self.nodeWidgets.has(event.target)) {
              if (!self.selectedNodeWidgets.has(event.target)) {
                self.selectNodeWidgets([event.target], event.detail.ctrlKey);
              }
            }
          });
        },
        _setupSetWidgetDragging: function(setWidget) {
          var self = this;
          setWidget.addEventListener('dragStart', function(event) {
            if (event.detail.target === setWidget.widgetHandle) {
              event.detail.preventDefault();
              self.startDraggingSelected(event);
              return false;
            }
          });
        },
        _setupSetWidgetMenu: function(setWidget) {
          var self = this;
          setWidget.addEventListener('contextMenu', function(event) {
            if (event.detail.target === setWidget.widgetHandle) {
              if (!self.draggingConnectors.length) {
              
                self.openSelectionMenu(event.detail);
              }
            }
          });
        },
        dropTargetAttached: function(event) {
          this.dropTargets.add(event.detail);
        },
        dropTargetDetached: function(event) {
          this.dropTargets.delete(event.detail);
        },
        openBackgroundMenu: function(position) {
          this.$.backgroundDropdown.style.position = 'absolute';
          this.$.backgroundDropdown.style.left = position.x + 'px';
          this.$.backgroundDropdown.style.top  = position.y + 'px';
          this.$.backgroundDropdown.style.display = 'block';
        },
        closeBackgroundMenu: function() {
          this.$.backgroundDropdown.style.display = 'none';
        },
        openSelectionMenu: function(event) {
          this.closeBackgroundMenu();
          
          var surfaceRect = this.getBoundingClientRect();
          this.$.selectionDropdown.style.position = 'absolute';
          this.$.selectionDropdown.style.left = (event.pageX - surfaceRect.left) + 'px';
          this.$.selectionDropdown.style.top  = (event.pageY - surfaceRect.top)  + 'px';
          this.$.selectionDropdown.style.display = 'block';
        },
        closeSelectionMenu() {
          this.$.selectionDropdown.style.display = 'none';
        },
        menuItem_CreateNode: function() {
          this.closeBackgroundMenu();
          this.createNodeWidget(this.lastMenuPosition);
        },
        menuItem_CreateSet: function() {
          this.closeBackgroundMenu();
          this.createSetWidget(this.lastMenuPosition);
        },
        menuItem_DeleteSelected: function() {
          var self = this;
          self.closeSelectionMenu();
          var linksToDelete = self.removeSelectedWidgets();
          linksToDelete.forEach(function(linkKey) {
            self.client.unsetLink(self.node_id.linkFromKey(linkKey));
          });
        },
        menuItem_HideSelected: function() {
          this.closeSelectionMenu();
          this.removeSelectedWidgets();
        },
        menuItem_CopySelected: function() {
          this.closeSelectionMenu();
          var offset = 10;
          this.copySelected(offset);
        },
        menuItem_RevealLinks: function() {
          this.closeSelectionMenu();
          this.revealLinksInSelected();
        },
        menuItem_HideLinks: function() {
          this.closeSelectionMenu();
          this.removeSelectedConnectors();
          this.removeConnectorsBetweenSelectedNodeWidgets();
        },
      });
    })();
  </script>

</dom-module>